<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tropical-Forest</title>
  
  <subtitle>个人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://tropical-forest.github.io/"/>
  <updated>2022-01-21T10:11:25.421Z</updated>
  <id>https://tropical-forest.github.io/</id>
  
  <author>
    <name>Tropical-Forest</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>全局异常处理与Retry重试</title>
    <link href="https://tropical-forest.github.io/2022/01/21/%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E4%B8%8ERetry%E9%87%8D%E8%AF%95/"/>
    <id>https://tropical-forest.github.io/2022/01/21/%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E4%B8%8ERetry%E9%87%8D%E8%AF%95/</id>
    <published>2022-01-21T10:09:32.000Z</published>
    <updated>2022-01-21T10:11:25.421Z</updated>
    
    <content type="html"><![CDATA[<h1 id="全局异常处理与Retry重试"><a href="#全局异常处理与Retry重试" class="headerlink" title="全局异常处理与Retry重试"></a>全局异常处理与Retry重试</h1><p>​    使用Web应用·时，在请求处理过程中发送错误是非常常见的情况。Spring Boot为我们提供了一个默认的映射：/error，当处理中抛出异常之后，会转到该请求中处理，并且该请求有一个全局的错误页面用来展示异常内容。比如现在启动my-spring-boot项目（启动项目前，记得启动Redis服务和ActiveMQ服务）,项目启动完成之后，在浏览器中随便输入一个访问地址，比如<a href="http://localhost:8080/ayUser/testdddd，由于该地址不存在，Spring" target="_blank" rel="noopener">http://localhost:8080/ayUser/testdddd，由于该地址不存在，Spring</a> Boot会跳转到错误页面。如下图所示:</p><p><img src="/2022/01/21/%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E4%B8%8ERetry%E9%87%8D%E8%AF%95/image-20220121161958943.png" alt="image-20220121161958943"></p><p>​    虽然Spring Boot为我们提供了默认的错误页面映射，但是在实际应用中，上述页面对用户不友好。因此我们需要自己来实现异常提示。</p><h2 id="Spring-Boot全局异常使用"><a href="#Spring-Boot全局异常使用" class="headerlink" title="Spring Boot全局异常使用"></a>Spring Boot全局异常使用</h2><h3 id="自定义错误页面"><a href="#自定义错误页面" class="headerlink" title="自定义错误页面"></a>自定义错误页面</h3><p>在项目目录/src/main/resources/static下新建自定义错误页面404.html，具体的代码如下:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"text"</span> <span class="attr">style</span>=<span class="string">"text-align: center"</span>&gt;</span></span><br><span class="line">        主人，我累了，让我休息一会！！！</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在项目目录/src/main/java/con.lpy下新建包error,并在包下新建ErrorPageConfig配置类，具体代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErrorPageConfig</span> <span class="keyword">implements</span> <span class="title">ErrorPageRegistrar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerErrorPages</span><span class="params">(ErrorPageRegistry registry)</span> </span>&#123;</span><br><span class="line">        ErrorPage error400Page = <span class="keyword">new</span> ErrorPage(HttpStatus.BAD_REQUEST, <span class="string">"/404.html"</span>);</span><br><span class="line">        ErrorPage error401Page = <span class="keyword">new</span> ErrorPage(HttpStatus.UNAUTHORIZED, <span class="string">"/404.html"</span>);</span><br><span class="line">        ErrorPage error404Page = <span class="keyword">new</span> ErrorPage(HttpStatus.NOT_FOUND, <span class="string">"/404.html"</span>);</span><br><span class="line">        ErrorPage error500Page = <span class="keyword">new</span> ErrorPage(HttpStatus.INTERNAL_SERVER_ERROR, <span class="string">"/404.html"</span>);</span><br><span class="line">        registry.addErrorPages(error400Page,error401Page,error404Page,error500Page);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>访问一个不存在的地址，由于该链接不存在，因此会出现自定义错误页面。</p><p><img src="/2022/01/21/%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E4%B8%8ERetry%E9%87%8D%E8%AF%95/image-20220121164258743.png" alt="image-20220121164258743"></p><h3 id="全局异常类开发"><a href="#全局异常类开发" class="headerlink" title="全局异常类开发"></a>全局异常类开发</h3><p>首先统一封装自定义业务异常BusinessException，该类继承自RuntimeException异常类，并提供带有异常信息的构造方法，具体代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BusinessException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BusinessException</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BusinessException</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在项目目录下/src/main/java/com.lpy.error下新建错误信息类ErrorInfo,该类用于封装错误信息，包括错误码，具体代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErrorInfo</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer SUCCESS = <span class="number">200</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer ERROR = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">//错误信息</span></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="comment">//错误码</span></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Data的使用需要安装插件lombok</p><p>其次，在项目目录下/src/main/java/com.lpy.error下新建统一异常处理类GlobalDefaultExceptionHandler，具体代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span>(basePackages = <span class="string">"com.lpy"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalDefaultExceptionHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(BusinessException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseBody</span></span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">ErrorInfo</span> <span class="title">defaultErrorHandler</span>(<span class="title">HttpServletRequest</span> <span class="title">req</span>, <span class="title">Exception</span> <span class="title">e</span>) <span class="title">throws</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">        ErrorInfo errorInfo = <span class="keyword">new</span> ErrorInfo();</span><br><span class="line">        errorInfo.setMessage(e.getMessage());</span><br><span class="line">        errorInfo.setUrl(req.getRequestURI());</span><br><span class="line">        errorInfo.setCode(ErrorInfo.SUCCESS);</span><br><span class="line">        <span class="keyword">return</span> errorInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>@ControllerAdvice: 定义统一的异常处理类</li><li>@ExceptionHandler： 用来定义函数针对的异常类型，可以传入多个需要捕获的异常类</li><li>@ResponseBody：如果返回的为json数据或其他对象，就添加该注解</li></ul><p>最后，在AyUserController类下添加控制层方法findAll,并在方法里抛出BusinessException，该异常会被全局异常类捕获到，具体代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/ayUser"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AyUserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> AyUserService ayUserService;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@RequestMapping</span>(<span class="string">"/findAll"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">findAll</span><span class="params">(Model model)</span> </span>&#123;</span><br><span class="line">      List&lt;AyUser&gt; ayUser = ayUserService.findAll();</span><br><span class="line">      model.addAttribute(<span class="string">"users"</span>,ayUser);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(<span class="string">"业务异常"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">//省略其他代码</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><p>重新启动项目，项目启动成功后，在浏览器中访问地址<a href="http://localhost:8088/ayUser/findAll，可以看到后端返回的json信息，具体信息如下所示" target="_blank" rel="noopener">http://localhost:8088/ayUser/findAll，可以看到后端返回的json信息，具体信息如下所示</a>:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"message"</span>:<span class="string">"业务异常"</span>,<span class="attr">"code"</span>:<span class="number">200</span>,<span class="attr">"url"</span>:<span class="string">"/ayUser/findAll"</span>,<span class="attr">"data"</span>:<span class="literal">null</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="Retry重试机制"><a href="#Retry重试机制" class="headerlink" title="Retry重试机制"></a>Retry重试机制</h2><h3 id="Retry重试介绍"><a href="#Retry重试介绍" class="headerlink" title="Retry重试介绍"></a>Retry重试介绍</h3><p>​    当我们调用一个接口时，可能由于网络等原因造成第一次失败，再去尝试就成功了，这就是重试机制。重试的解决方案有很多，比如利用try-catch-redo简单重试模式，通过判断返回结果或监听异常来判断是否重试。</p><p>​    try-catch-redo重试模式还有可能重试无效，解决这个问题的方法是尝试增加重试次数（retrycount)和重试间隔周期（interval)，以达到增加重试有效的可能性，因此我们可以利用try-catch-redo-retry strategy策略重试模式</p><p>​    但是这两种策略有一个共同问题就是：正常逻辑和重试逻辑强耦合。基于这些问题，对于Spring-Retry规范正常逻辑和重试逻辑，将正常逻辑和重试逻辑解耦。Spring-Retry是一个开源包，该工具把重试模板定制化，可以设置重试策略和回退策略。同时，重试执行实例保证线程安全。Spring-Retry重试可以用java代码方式实现，也可以用注解@Retryable实现，这样用注解的方法对方法进行重试。</p><h3 id="Retry重试机制的使用"><a href="#Retry重试机制的使用" class="headerlink" title="Retry重试机制的使用"></a>Retry重试机制的使用</h3><p>引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.retry<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-retry<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​    依赖添加完成之后，我们需要在入口类中添加注解@EnableRetry开启Retry重试。完整代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@ServletComponentScan</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="meta">@EnableRetry</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringbootDruidApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringbootDruidApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，在AyUserService类下添加新接口findByNameAndPasswordRetry,具体代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">AyUser <span class="title">findByNameAndPasswordRetry</span><span class="params">(String name, String password)</span></span>;</span><br></pre></td></tr></table></figure><p>我们在AyUserServiceImpl类实现接口findByNamePasswordRetry，并在方法中故意抛出业务异常，具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Retryable</span>(value = BusinessException<span class="class">.<span class="keyword">class</span>,<span class="title">maxAttempts</span> </span>= <span class="number">5</span>,backoff = <span class="meta">@Backoff</span>(delay = <span class="number">5000</span>,multiplier = <span class="number">2</span>))</span><br><span class="line"><span class="function"><span class="keyword">public</span> AyUser <span class="title">findByNameAndPasswordRetry</span><span class="params">(String name, String password)</span> </span>&#123;</span><br><span class="line">    logger.info(<span class="string">"[findByNameAndPasswordRetry] 方法失败重试了！ "</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException();</span><br><span class="line">    <span class="comment">//return null;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Retryable: value属性表示当出现哪些异常的时候触发重试，maxAttempts表示最大重试次数，默认为3，delay表示重试的延迟时间，multiplier表示上一次延时时间是这一次的倍数。</p><p>最后，我们在AyUserController类下添加控制层方法findByNamePasswordRetry，在该方法中调用服务层AyUserServiceImpl的方法findByNameAndPasswordRetry，具体代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/findByNameAndPasswordRetry"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">findByNamePasswordRetry</span><span class="params">(Model model)</span> </span>&#123;</span><br><span class="line">    AyUser ayUser = ayUserService.findByNameAndPasswordRetry(<span class="string">"阿毅"</span>, <span class="string">"123456"</span>);</span><br><span class="line">    model.addAttribute(<span class="string">"users"</span>,ayUser);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h3><p>重新启动项目，访问<a href="http://localhost:8088/ayUser/findByNameAndPasswordRetry，我们可以从控制台中多次看到如下打印信息" target="_blank" rel="noopener">http://localhost:8088/ayUser/findByNameAndPasswordRetry，我们可以从控制台中多次看到如下打印信息</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[findByNameAndPasswordRetry] 方法失败重试了！</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;全局异常处理与Retry重试&quot;&gt;&lt;a href=&quot;#全局异常处理与Retry重试&quot; class=&quot;headerlink&quot; title=&quot;全局异常处理与Retry重试&quot;&gt;&lt;/a&gt;全局异常处理与Retry重试&lt;/h1&gt;&lt;p&gt;​    使用Web应用·时，在请求处理过程
      
    
    </summary>
    
    
      <category term="SpringBoot" scheme="https://tropical-forest.github.io/categories/SpringBoot/"/>
    
    
      <category term="全局异常处理" scheme="https://tropical-forest.github.io/tags/%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>异步消息和异步调用</title>
    <link href="https://tropical-forest.github.io/2022/01/21/%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF%E5%92%8C%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8/"/>
    <id>https://tropical-forest.github.io/2022/01/21/%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF%E5%92%8C%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8/</id>
    <published>2022-01-21T03:45:31.000Z</published>
    <updated>2022-01-21T04:06:40.681Z</updated>
    
    <content type="html"><![CDATA[<h1 id="异步消息和异步调用"><a href="#异步消息和异步调用" class="headerlink" title="异步消息和异步调用"></a>异步消息和异步调用</h1><h2 id="JMS消息介绍"><a href="#JMS消息介绍" class="headerlink" title="JMS消息介绍"></a>JMS消息介绍</h2><p><strong>Java消息服务</strong>（<strong>Java Message Service</strong>，<strong>JMS</strong>）应用程序接口是一个java平台中关于<a href="https://zh.wikipedia.org/w/index.php?title=面向消息中间件&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">面向消息中间件</a>（MOM）的<a href="https://zh.wikipedia.org/wiki/API" target="_blank" rel="noopener">API</a>，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。Java消息服务是一个与具体平台无关的API，绝大多数MOM提供商都对JMS提供支持。</p><p>Java消息服务的规范包括两种消息模式，点对点(P2P)和发布者／订阅者(pub/sub)。许多提供商支持这一通用框架因此，程序员可以在他们的分布式软件中实现面向消息的操作，这些操作将具有不同面向消息中间件产品的可移植性。</p><p>Java消息服务支持同步和异步的消息处理，在某些场景下，同步消息是必要的；在其他场景下，异步消息比同步消息操作更加便利。</p><p>Java消息服务支持面向事件的方法接收消息，<a href="https://zh.wikipedia.org/wiki/事件驅動程式設計" target="_blank" rel="noopener">事件驱动的程序设计</a>现在被广泛认为是一种富有成效的<a href="https://zh.wikipedia.org/wiki/编程范型" target="_blank" rel="noopener">程序设计范例</a>，程序员们都相当熟悉。</p><p>在应用系统开发时，Java消息服务可以推迟选择面对消息中间件产品，也可以在不同的面对消息中间件切换。</p><p>​    P2P的特点是每个消息只有一个消费者（一旦被消费，消息就不在消息队列中），发送者和接收者之间在时间上没有依赖性。也就是说当发送者发送了消息之后，无论接收者有没有正在运行，都不会影响消息被发送到队列中，接收者在成功接收消息之后需向队列应答成功。</p><p>​    另一种称为Pub/Sub模型。发布-订阅模型定义了如何向一个内容节点发布和订阅消息，这个内容节点称为topic(主题)。主题可以认为是消息传递的中介，消息发布者将消息发布到某个主题，而消息订阅者则从主题订阅消息。主题使得消息的订阅者与消息的发布者互相保持独立，不需要进行接触即可保证消息的传递，发布-订阅模型在消息的一对多广播时采用。</p><p><img src="/2022/01/21/%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF%E5%92%8C%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8/image-20220119223953741.png" alt="image-20220119223953741"></p><p>​    Pub/Sub的特点是每个消息可以有多个消费者，发布者和订阅者之间有时间上的依赖性。针对某个主题的订阅者，必须创建一个订阅者之后，才能消费发布者的消息，而且为了消费消息，订阅者必须保持运行的状态。为了缓和这样严格的时间相关性，JMS允许订阅者创建一个可持久化的订阅。这样，即使订阅者没有被激活(运行)，也能接收到发布者的消息。如果你希望发送的消息可以不做任何处理、被一个消息者处理或者可以被多个消费者处理，那么可以采用Pub/Sub模型。</p><h2 id="Spring-Boot-集成ActiveMQ"><a href="#Spring-Boot-集成ActiveMQ" class="headerlink" title="Spring Boot 集成ActiveMQ"></a>Spring Boot 集成ActiveMQ</h2><h3 id="ActiveMQ概述"><a href="#ActiveMQ概述" class="headerlink" title="ActiveMQ概述"></a>ActiveMQ概述</h3><p>​    MQ全称为MessageQueue,中文名为消息队列，是一个消息的接收和转发的容器，可用于消息推送。ActiveMQ是Apache提供的一个开源消息系统，完成采用Java来实现，因此能够很好地支持J2EE提出的JMS规范。</p><h3 id="ActiveMQ的安装"><a href="#ActiveMQ的安装" class="headerlink" title="ActiveMQ的安装"></a>ActiveMQ的安装</h3><p>下载地址:<a href="https://activemq.apache.org/" target="_blank" rel="noopener">https://activemq.apache.org/</a></p><p>解压后进入bin目录，根据操作系统进入win32文件夹还是win64文件夹，双击activemq.bat即可启动。</p><p>出现下图则表示安装成功:</p><p><img src="/2022/01/21/%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF%E5%92%8C%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8/image-20220119225443649.png" alt="image-20220119225443649"></p><p>安装成功后，在浏览器中输入<a href="http://localhost:8161/admin链接访问，第一次访问需要输入用户名admin和密码admin进行登录，登录成功后可看到ActiveMQ的首页，如下图所示" target="_blank" rel="noopener">http://localhost:8161/admin链接访问，第一次访问需要输入用户名admin和密码admin进行登录，登录成功后可看到ActiveMQ的首页，如下图所示</a>:</p><p><img src="/2022/01/21/%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF%E5%92%8C%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8/image-20220119225815294.png" alt="image-20220119225815294"></p><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><p>在Spring Boot 中集成ActiveMQ，首先需要在pom.xml文件中引入所需的依赖，具体代码如下:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-activemq<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="添加ActiveMQ配置"><a href="#添加ActiveMQ配置" class="headerlink" title="添加ActiveMQ配置"></a>添加ActiveMQ配置</h3><p>我们需要在application.yaml配置文件中添加ActiveMQ配置，具体代码如下:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">activemq:</span></span><br><span class="line">    <span class="attr">broker-url:</span> <span class="string">tcp://localhost:61616</span></span><br><span class="line">    <span class="attr">in-memory:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">pool:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">packages:</span></span><br><span class="line">      <span class="attr">trust-all:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><ul><li>spring.activemq.packages.trust-all： ObjectMessage的使用声明机制是不安全的，ActiveMQ自5.12.2和5.13.0之后，强制Consumer端声明一份可信任的包列表。只有当ObjectMessage中的Object在可信任包内，才能被提取处理。该配置表示信任所有的包。</li></ul><h2 id="使用ActiveMQ"><a href="#使用ActiveMQ" class="headerlink" title="使用ActiveMQ"></a>使用ActiveMQ</h2><h3 id="创建生产者"><a href="#创建生产者" class="headerlink" title="创建生产者"></a>创建生产者</h3><p>在数据库中建立说说表ay_mood，具体建表语句如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE IF EXISTS &#96;ay_mood&#96;;</span><br><span class="line">CREATE TABLE &#96;ay_mood&#96;  (</span><br><span class="line">  &#96;id&#96; varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,</span><br><span class="line">  &#96;content&#96; varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,</span><br><span class="line">  &#96;user_id&#96; varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,</span><br><span class="line">  &#96;praise_num&#96; int(11) NULL DEFAULT NULL,</span><br><span class="line">  &#96;publish_time&#96; datetime NULL DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;),</span><br><span class="line">  key &#96;mood_user_id_index&#96; (&#96;user_id&#96;) using btree</span><br><span class="line">) ENGINE &#x3D; InnoDB CHARACTER SET &#x3D; utf8 COLLATE &#x3D; utf8_general_ci ROW_FORMAT &#x3D; Compact;</span><br></pre></td></tr></table></figure><p>数据库表建好之后，生成对应的Java Bean对象，具体代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name = <span class="string">"ay_mood"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AyMood</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="comment">//说说内容</span></span><br><span class="line">    <span class="keyword">private</span>  String content;</span><br><span class="line">    <span class="comment">//用户id</span></span><br><span class="line">    <span class="keyword">private</span> String userId;</span><br><span class="line">    <span class="comment">//点赞个数</span></span><br><span class="line">    <span class="keyword">private</span>  Integer praiseNum;</span><br><span class="line">    <span class="comment">//发表时间</span></span><br><span class="line">    <span class="keyword">private</span> Date publishTime;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中@Data的使用需要安装lombok插件，该注解会帮你自动生成set.get等方法。</p><p>AyMoode实体对象开发完成之后，开发对应的AyMoodRepository接口，具体代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AyMoodRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">AyMood</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    Repository接口开发完成之后，开发对应的说说服务层接口AyMoodService和相应的实现类AyMoodServiceImpl。AyMoodService具体代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述:微信说说服务层</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AyMoodService</span> </span>&#123;</span><br><span class="line">    <span class="function">AyMood <span class="title">savee</span><span class="params">(AyMood ayMood)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AyMoodServiceImpl</span> <span class="keyword">implements</span> <span class="title">AyMoodService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> AyMoodRepository ayMoodRepository;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AyMood <span class="title">savee</span><span class="params">(AyMood ayMood)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ayMoodRepository.save(ayMood);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span>  AyMoodService ayMoodService;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAyMood</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AyMood ayMood = <span class="keyword">new</span> AyMood();</span><br><span class="line">    ayMood.setId(<span class="string">"1"</span>);</span><br><span class="line">    ayMood.setUserId(<span class="string">"1"</span>);</span><br><span class="line">    ayMood.setPraiseNum(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//说说内容</span></span><br><span class="line">    ayMood.setContent(<span class="string">"这是我的第一条微信说说"</span>);</span><br><span class="line">    ayMood.setPublishTime(<span class="keyword">new</span> Date());</span><br><span class="line">    AyMood mood = ayMoodService.save(ayMood);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    运行测试用例，运行成功后，可以在数据库表ay_mood中看到一条数据。如下图所示:</p><p><img src="/2022/01/21/%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF%E5%92%8C%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8/image-20220120083242658.png" alt="image-20220120083242658"></p><p>​    微信的用户量极大，我们不可能找到用户每发一次说说，后端就单独开一个线程，并将该说说内容实时保存到数据库中。因为后端服务系统的线程数和数据库线程池中的线程数量都是固定而且宝贵的，这样会给后端服务和数据库造成带来极大的压力。所以我们使用ActiveMQ做异步消费来抵抗用户量大及发表说说而产生的压力，提高系统整体的性能。</p><p>​    生产者AyMoodProducer的代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AyMoodProducer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> JmsMessagingTemplate jmsMessagingTemplate;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(Destination destination, <span class="keyword">final</span> String message)</span> </span>&#123;</span><br><span class="line">        jmsMessagingTemplate.convertAndSend(destination, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>JmsMessagingTemplate： 发消息的工具类，也可以注入JmsTemplate,JmsMessagingTemplate对JmsTemplate进行了封装。参数destination是发送到队列的，message是待发送的消息。</li></ul><h3 id="创建消费者"><a href="#创建消费者" class="headerlink" title="创建消费者"></a>创建消费者</h3><p>消费者AyMoodConsumer,具体代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AyMoodConsumer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@JmsListener</span>(destination = <span class="string">"ay.queue"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveQueue</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"用户发表说说【"</span>+text+<span class="string">"】成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>@JmsListener：使用JmsListener配置消费者监听的队列ay.queue，其中text是接收到的消息。</li></ul><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> AyMoodProducer ayMoodProducer;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testActiveMQ</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Destination destination = <span class="keyword">new</span> ActiveMQQueue((<span class="string">"ay.queue"</span>));</span><br><span class="line">    ayMoodProducer.sendMessage(destination,<span class="string">"hello,mq!!!!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行测试方法，可以看到以下打印信息。同时可以在浏览器中访问<a href="http://localhost:8161/admin/，查看队列ay.queue的消费情况。" target="_blank" rel="noopener">http://localhost:8161/admin/，查看队列ay.queue的消费情况。</a></p><p><img src="/2022/01/21/%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF%E5%92%8C%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8/image-20220120180712786.png" alt="image-20220120180712786"></p><p><img src="/2022/01/21/%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF%E5%92%8C%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8/image-20220120180905458.png" alt="image-20220120180905458"></p><p>生产者和消费者开发完成之后，现在我们把用户发表说说改成异步消费模式。首先在AyMoodService类下添加异步保存接口asynSave(),具体代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述:微信说说服务层</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AyMoodService</span> </span>&#123;</span><br><span class="line">    <span class="function">AyMood <span class="title">save</span><span class="params">(AyMood ayMood)</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">asynSave</span><span class="params">(AyMood ayMood)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在类AyMoodServiceImpl下实现asynSave方法，asynSave方法并不保存说说记录，而是调用AyMoodProducer类的sendMessage推送消息，完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AyMoodServiceImpl</span> <span class="keyword">implements</span> <span class="title">AyMoodService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> AyMoodRepository ayMoodRepository;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AyMood <span class="title">save</span><span class="params">(AyMood ayMood)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ayMoodRepository.save(ayMood);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Destination destination = <span class="keyword">new</span> ActiveMQQueue(<span class="string">"ay.queue.asyn.save"</span>);</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> AyMoodProducer ayMoodProducer;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">asynSave</span><span class="params">(AyMood ayMood)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//往队列ay.queue.asyn.save推送消息，消息内容为说说实体</span></span><br><span class="line">        ayMoodProducer.sendMessage(destination, ayMood);</span><br><span class="line">        <span class="keyword">return</span>  <span class="string">"success"</span>;</span><br><span class="line">        <span class="comment">//return null;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其次，在AyMoodProducer生产者类下添加sendMessage(Destination destination, final AyMood ayMood)方法，消息内容是ayMood实体对象。AyMoodProducer生产者的完整代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AyMoodProducer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> JmsMessagingTemplate jmsMessagingTemplate;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(Destination destination, <span class="keyword">final</span> String message)</span> </span>&#123;</span><br><span class="line">        jmsMessagingTemplate.convertAndSend(destination, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(Destination destination, <span class="keyword">final</span> AyMood ayMood)</span> </span>&#123;</span><br><span class="line">        jmsMessagingTemplate.convertAndSend(destination,ayMood);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，修改AyMoodConsumer消费者，在receiveQueue方法中保持说说记录，完整代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AyMoodConsumer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@JmsListener</span>(destination = <span class="string">"ay.queue"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveQueue</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"用户发表说说【"</span>+text+<span class="string">"】成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> AyMoodService ayMoodService;</span><br><span class="line">    <span class="meta">@JmsListener</span>(destination = <span class="string">"ay.queue.asyn.save"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveQueue</span><span class="params">(AyMood ayMood)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"异步保存，异步保存"</span>);</span><br><span class="line">        ayMoodService.save(ayMood);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用户发表说说，异步保存所有代码开发完成之后，在测试类中添加testActiveMQAsynSave测试方法，具体代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testActiveMQAsynSave</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       AyMood ayMood = <span class="keyword">new</span> AyMood();</span><br><span class="line">       ayMood.setId(<span class="string">"2"</span>);</span><br><span class="line">       ayMood.setUserId(<span class="string">"2"</span>);</span><br><span class="line">       ayMood.setPraiseNum(<span class="number">0</span>);</span><br><span class="line">       ayMood.setContent(<span class="string">"这是我的第一条微信说说！！！"</span>);</span><br><span class="line">       ayMood.setPublishTime(<span class="keyword">new</span> Date());</span><br><span class="line">       String msg = ayMoodService.asynSave(ayMood);</span><br><span class="line">       System.out.println(<span class="string">"异步发表说说："</span> + msg);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>运行测试方法，成功之后，我们可以在数据库表ay_mood中查询到用户（id为2）发表的记录。如下图所示:</p><p><img src="/2022/01/21/%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF%E5%92%8C%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8/image-20220121102225241.png" alt="image-20220121102225241"></p><h2 id="Spring-Boot-异步调用"><a href="#Spring-Boot-异步调用" class="headerlink" title="Spring Boot 异步调用"></a>Spring Boot 异步调用</h2><h3 id="异步调用介绍"><a href="#异步调用介绍" class="headerlink" title="异步调用介绍"></a>异步调用介绍</h3><p>​    异步调用是相对于同步调用而言，同步调用是指程序按预定顺序一步步执行，每一步必须等到上一步执行完成之后才能执行，而异步调用无须等待上一步程序执行完成即可执行。在日常开发的项目中，当访问的接口较慢或者做耗时任务时，不想程序一直卡在耗时任务上，想让程序能够并行执行，我们除了可以使用多线程来并行地处理任务，也可以使用Spring Boot提供的异步处理方式@Async来处理。在Spring Boot框架中，只要添加@Async注解就能够将普通的同步任务改为异步调用任务。</p><h3 id="Async的使用"><a href="#Async的使用" class="headerlink" title="@Async的使用"></a>@Async的使用</h3><p>​    使用@Async注解之前，我们需要在入口类添加注解@EnableAsync开启异步调用，具体代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@ServletComponentScan</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringbootDruidApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringbootDruidApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，修改AyUserServiceImpl类的findAll方法，使它能够记录代码执行完成所花费的时间，具体代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;AyUser&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// return ayUserRepository.findAll();</span></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"开始做任务"</span>);</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        List&lt;AyUser&gt; ayUserList = ayUserRepository.findAll();</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"完成任务，耗时："</span> +(end-start)+<span class="string">"毫秒"</span>);</span><br><span class="line">        <span class="keyword">return</span> ayUserList;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.error(<span class="string">"method [findAll] error"</span>, e);</span><br><span class="line">        <span class="keyword">return</span> Collections.EMPTY_LIST;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><p>​        AyUserServiceImpl类的方法findAll()开发完成之后，在测试类上添加测试方法testAsync(),该方法调用3次findAll(),并记录总共消耗的时间，由于现在是同步调用，因此代码按照顺序一步一步执行。testAsync方法的具体代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAsync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">    logger.info(<span class="string">"第一次查询所有用户！"</span>);</span><br><span class="line">    List&lt;AyUser&gt; ayUserList1 = ayUserService.findAll();</span><br><span class="line">    logger.info(<span class="string">"第二次查询所有用户！"</span>);</span><br><span class="line">    List&lt;AyUser&gt; ayUserList2 = ayUserService.findAll();</span><br><span class="line">    logger.info(<span class="string">"第三次查询所有用户！"</span>);</span><br><span class="line">    List&lt;AyUser&gt; ayUserList3 = ayUserService.findAll();</span><br><span class="line">    <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">    logger.info(<span class="string">"总共消耗:"</span>+(endTime-startTime)+<span class="string">"毫秒"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试方法testAsync()开发完成之后，我们运行它，运行成功之后，可以在控制台看到如下打印信息。</p><p><img src="/2022/01/21/%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF%E5%92%8C%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8/Users\刘培永\Desktop\异步消息和异步调用\image-20220121114145722.png" alt="image-20220121114145722" style="zoom:50%;"></p><p>从打印结构可以看出，调用3次findAll总共消耗232毫秒。现在我们在AyUserService接口中添加异步查询方法findAsynAll()，并在AyUserServiceImpl类中实现该方法，具体代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AyUserService</span> </span>&#123;</span><br><span class="line">   <span class="comment">//省略其他代码</span></span><br><span class="line">    <span class="comment">//异步查询</span></span><br><span class="line">    Future&lt;List&lt;AyUser&gt;&gt; findAsynAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    在AyUserServiceImpl类中实现findAsynAll()方法，并在方法中添加异步调用注解@Async，具体代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Async</span></span><br><span class="line"><span class="keyword">public</span> Future&lt;List&lt;AyUser&gt;&gt; findAsynAll() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        logger.info(<span class="string">"开始做任务"</span>);</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        List&lt;AyUser&gt; ayUserList = ayUserRepository.findAll();</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        logger.info(<span class="string">"完成任务，耗时："</span>+(end-start)+<span class="string">"毫秒"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AsyncResult&lt;List&lt;AyUser&gt;&gt;(ayUserList);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.error(<span class="string">"method [findAll] error"</span>,e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AsyncResult&lt;List&lt;AyUser&gt;&gt;(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在测试类开发测试方法testAsync2(),具体代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAsync2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">    logger.info(<span class="string">"第一次查询所有用户！"</span>);</span><br><span class="line">    Future&lt;List&lt;AyUser&gt;&gt; ayUserList1 = ayUserService.findAsynAll();</span><br><span class="line">    logger.info(<span class="string">"第二次查询所有用户！"</span>);</span><br><span class="line">    Future&lt;List&lt;AyUser&gt;&gt; ayUserList2 = ayUserService.findAsynAll();</span><br><span class="line">    logger.info(<span class="string">"第三次查询所有用户！"</span>);</span><br><span class="line">    Future&lt;List&lt;AyUser&gt;&gt; ayUserList3 = ayUserService.findAsynAll();</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ayUserList1.isDone() &amp;&amp; ayUserList2.isDone()&amp;&amp; ayUserList3.isDone()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">    logger.info(<span class="string">"总共消耗:"</span>+(endTime-startTime)+<span class="string">"毫秒"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/01/21/%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF%E5%92%8C%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8/image-20220121114303677.png" style="zoom:50%;"></p><p>从上面结果可知，异步调用的速度比同步调用快。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;异步消息和异步调用&quot;&gt;&lt;a href=&quot;#异步消息和异步调用&quot; class=&quot;headerlink&quot; title=&quot;异步消息和异步调用&quot;&gt;&lt;/a&gt;异步消息和异步调用&lt;/h1&gt;&lt;h2 id=&quot;JMS消息介绍&quot;&gt;&lt;a href=&quot;#JMS消息介绍&quot; class=&quot;he
      
    
    </summary>
    
    
      <category term="SpringBoot" scheme="https://tropical-forest.github.io/categories/SpringBoot/"/>
    
    
      <category term="异步消息" scheme="https://tropical-forest.github.io/tags/%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF/"/>
    
      <category term="异步调用" scheme="https://tropical-forest.github.io/tags/%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8/"/>
    
      <category term="ActiveMQ" scheme="https://tropical-forest.github.io/tags/ActiveMQ/"/>
    
  </entry>
  
  <entry>
    <title>集成MyBatis</title>
    <link href="https://tropical-forest.github.io/2022/01/19/%E9%9B%86%E6%88%90MyBatis/"/>
    <id>https://tropical-forest.github.io/2022/01/19/%E9%9B%86%E6%88%90MyBatis/</id>
    <published>2022-01-19T12:53:02.000Z</published>
    <updated>2022-01-19T12:54:05.095Z</updated>
    
    <content type="html"><![CDATA[<h1 id="集成MyBatis"><a href="#集成MyBatis" class="headerlink" title="集成MyBatis"></a>集成MyBatis</h1><h2 id="MyBatis简介"><a href="#MyBatis简介" class="headerlink" title="MyBatis简介"></a>MyBatis简介</h2><p>​    MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</p><h2 id="集成MyBatis-1"><a href="#集成MyBatis-1" class="headerlink" title="集成MyBatis"></a>集成MyBatis</h2><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.mybatis.spring.boot/mybatis-spring-boot-starter --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="添加MyBatis配置"><a href="#添加MyBatis配置" class="headerlink" title="添加MyBatis配置"></a>添加MyBatis配置</h3><p>我们需要在application.yaml文件中添加如下配置信息:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:/mappers/*Mapper.xml</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.lpy.dao</span></span><br></pre></td></tr></table></figure><ul><li>mybatis.mapper-locations: Mapper资源文件存放的路径</li><li>mybatis.type-aliases-package: Dao接口文件存放的目录</li></ul><h3 id="Dao层和Mapper文件开发"><a href="#Dao层和Mapper文件开发" class="headerlink" title="Dao层和Mapper文件开发"></a>Dao层和Mapper文件开发</h3><p>application.yaml配置完成之后，我们需要根据MyBatis配置添加对应的文件夹。首先在/src/main/java/com.lpy.dao目录下新建AyUserDao接口，这样SpringBoot启动时，就可以根据applciaton.yaml配置mybatis.type-aliases-package,找到AyUserDao接口。AyUserDao具体代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AyUserDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 描述：通过用户名和密码查询用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">AyUser <span class="title">findByNamePassword</span><span class="params">(@Param(<span class="string">"name"</span>)</span> String name, @<span class="title">Param</span><span class="params">(<span class="string">"password"</span>)</span> String password)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>@Mapper: 重要注解，MyBatis根据接口定义与Mapper文件中的SQL语句动态创建接口实现</li><li>@Param:注解参数，在Mapper.xml配置文件中，可以采用#{}的方式对@Param注解括号内的参数进行引用。</li><li>findByNameAndPassword： 该方法可以通过用户名和密码查询用户</li></ul><p>​    然后在/src/main/resources目录下新建AyUserMapper.xml文件，Spring Boot在项目启动时，会根据application.yaml配置mybatis.mapper-locations找到该文件。AyUserMapper具体代码如下:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.lpy.dao.AyUserDao"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"UserResultMap"</span> <span class="attr">type</span>=<span class="string">"com.lpy.model.AyUser"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">jdbcType</span>=<span class="string">"VARCHAR"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"name"</span> <span class="attr">property</span>=<span class="string">"name"</span> <span class="attr">jdbcType</span>=<span class="string">"VARCHAR"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"password"</span> <span class="attr">property</span>=<span class="string">"password"</span> <span class="attr">jdbcType</span>=<span class="string">"VARCHAR"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findByNamePassword"</span> <span class="attr">resultMap</span>=<span class="string">"UserResultMap"</span> <span class="attr">parameterType</span>=<span class="string">"String"</span>&gt;</span></span><br><span class="line">        select * from ay_user u</span><br><span class="line">        <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">            u.name = #&#123;name&#125;</span><br><span class="line">            and u.password = #&#123;password&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><mapper>标签: 该标签的namespace属性用于绑定Dao接口</mapper></li><li>select 标签: 用来编写select语句，映射查询语句.select标签有几个重要的属性，比如resultMap。</li><li><resultMap>： 映射管理器resultMap,是Mybatis中最强大的工具，描述了如何将数据库查询的结果集映射到java对象，并管理结果和实体类之间的映射关系。</resultMap></li></ul><p>AyUserDao代码开发完成后，在之前开发好的AyUserService接口类添加接口接口findByNameAndPassword，具体代码下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AyUserService</span> </span>&#123;</span><br><span class="line">    <span class="function">AyUser <span class="title">findByNameAndPassword</span><span class="params">(String name, String password)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AyUserServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AyUserServiceImpl</span> <span class="keyword">implements</span> <span class="title">AyUserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//省略上面代码</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span>  AyUserDao ayUserDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AyUser <span class="title">findByNameAndPassword</span><span class="params">(String name, String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ayUserDao.findByNamePassword(name,password);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省略下面代码</span></span><br><span class="line"> |</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>在测试类中添加测试方法，具体代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMybatis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AyUser ayUser = ayUserService.findByNameAndPassword(<span class="string">"阿毅"</span>,<span class="string">"123456"</span>);</span><br><span class="line">    logger.info(ayUser.getId() + ayUser.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行测试用例，在IDEA控制台可以看到相应的打印信息。</p><p>需要注意：在数据库有很多表的时候，一定不要手写mapp.xml代码，要用mybatis逆向工程自动生成mapper文件，具体做法自己百度。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;集成MyBatis&quot;&gt;&lt;a href=&quot;#集成MyBatis&quot; class=&quot;headerlink&quot; title=&quot;集成MyBatis&quot;&gt;&lt;/a&gt;集成MyBatis&lt;/h1&gt;&lt;h2 id=&quot;MyBatis简介&quot;&gt;&lt;a href=&quot;#MyBatis简介&quot; class
      
    
    </summary>
    
    
      <category term="SpringBoot" scheme="https://tropical-forest.github.io/categories/SpringBoot/"/>
    
    
      <category term="MyBatis" scheme="https://tropical-forest.github.io/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>Quartz定时器和发送Email</title>
    <link href="https://tropical-forest.github.io/2022/01/19/Quartz%E5%AE%9A%E6%97%B6%E5%99%A8%E5%92%8C%E5%8F%91%E9%80%81Email/"/>
    <id>https://tropical-forest.github.io/2022/01/19/Quartz%E5%AE%9A%E6%97%B6%E5%99%A8%E5%92%8C%E5%8F%91%E9%80%81Email/</id>
    <published>2022-01-19T11:26:51.000Z</published>
    <updated>2022-01-19T11:29:29.692Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Quartz定时器和发送Email"><a href="#Quartz定时器和发送Email" class="headerlink" title="Quartz定时器和发送Email"></a>Quartz定时器和发送Email</h1><h2 id="使用Quartz-定时器"><a href="#使用Quartz-定时器" class="headerlink" title="使用Quartz 定时器"></a>使用Quartz 定时器</h2><h3 id="Quartz概述"><a href="#Quartz概述" class="headerlink" title="Quartz概述"></a>Quartz概述</h3><ul><li><p>Quartz 是一个完全由 Java 编写的开源作业调度框架，为在 Java 应用程序中进行作业调度提供了简单却强大的机制。</p></li><li><p>Quartz 可以与J2EE 与 J2SE 应用程序相结合也可以单独使用。</p></li><li><p>Quartz 允许程序开发人员根据时间的间隔来调度作业。</p></li><li><p>Quartz 实现了作业和触发器的多对多的关系，还能把多个作业与不同的触发器关联。</p></li><li>Quartz 定时器的作用很多，比如定式发送信息、定时生成报表、定时取消订单等</li></ul><p>​    Quartz框架主要核心组件包括调度器、触发器、作业。调度器作为作业的总指挥，触发器作为作业的操作者，作业为应用的功能模块。</p><p>其关系如下图所示:</p><p><img src="/2022/01/19/Quartz%E5%AE%9A%E6%97%B6%E5%99%A8%E5%92%8C%E5%8F%91%E9%80%81Email/image-20220119162829667.png" alt="image-20220119162829667"></p><p>(1) Job </p><p>表示一个工作，要执行的具体内容。此接口中只有一个方法，如下：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">void</span> <span class="function"><span class="title"><span class="built_in">execute</span></span>(<span class="variable">JobExecutionContext</span> <span class="variable">context</span>)</span></span><br></pre></td></tr></table></figure><p>(2) <strong>JobDetail</strong> 表示一个具体的可执行的调度程序，Job 是这个可执行程调度程序所要执行的内容，另外 JobDetail 还包含了这个任务调度的方案和策略。</p><p>(3) <strong>Trigger</strong> 代表一个调度参数的配置，什么时候去调。</p><p>(4) <strong>Scheduler</strong> 代表一个调度容器，一个调度容器中可以注册多个 JobDetail 和 Trigger。当 Trigger 与 JobDetail 组合，就可以被 Scheduler 容器调度了。</p><p>CronTrigger配置格式:</p><p>格式: [秒] [分] [小时] [日] [月] [周] [年]</p><div class="table-container"><table><thead><tr><th>序号</th><th>说明</th><th>是否必填</th><th>允许填写的值</th><th style="text-align:center">允许的通配符</th></tr></thead><tbody><tr><td>1</td><td>秒</td><td>是</td><td>0-59</td><td style="text-align:center">, - * /</td></tr><tr><td>2</td><td>分</td><td>是</td><td>0-59</td><td style="text-align:center">, - * /</td></tr><tr><td>3</td><td>小时</td><td>是</td><td>0-23</td><td style="text-align:center">, - * /</td></tr><tr><td>4</td><td>日</td><td>是</td><td>1-31</td><td style="text-align:center">, - * ? / L W</td></tr><tr><td>5</td><td>月</td><td>是</td><td>1-12 or JAN-DEC</td><td style="text-align:center">, - * /</td></tr><tr><td>6</td><td>周</td><td>是</td><td>1-7 or SUN-SAT</td><td style="text-align:center">, - * ? / L #</td></tr><tr><td>7</td><td>年</td><td>否</td><td>empty 或 1970-2099</td><td style="text-align:center">, - * /</td></tr></tbody></table></div><p>常用示例:</p><div class="table-container"><table><thead><tr><th><code>0 0 12 * * ?</code></th><th style="text-align:left">每天12点触发</th></tr></thead><tbody><tr><td><code>0 15 10 ? * *</code></td><td style="text-align:left">每天10点15分触发</td></tr><tr><td><code>0 15 10 * * ?</code></td><td style="text-align:left">每天10点15分触发</td></tr><tr><td><code>0 15 10 * * ? *</code></td><td style="text-align:left">每天10点15分触发</td></tr><tr><td><code>0 15 10 * * ? 2005</code></td><td style="text-align:left">2005年每天10点15分触发</td></tr><tr><td><code>0 * 14 * * ?</code></td><td style="text-align:left">每天下午的 2点到2点59分每分触发</td></tr><tr><td><code>0 0/5 14 * * ?</code></td><td style="text-align:left">每天下午的 2点到2点59分(整点开始，每隔5分触发)</td></tr><tr><td><code>0 0/5 14,18 * * ?</code></td><td style="text-align:left">每天下午的 2点到2点59分(整点开始，每隔5分触发) 每天下午的 18点到18点59分(整点开始，每隔5分触发)</td></tr><tr><td><code>0 0-5 14 * * ?</code></td><td style="text-align:left">每天下午的 2点到2点05分每分触发</td></tr><tr><td><code>0 10,44 14 ? 3 WED</code></td><td style="text-align:left">3月分每周三下午的 2点10分和2点44分触发</td></tr><tr><td><code>0 15 10 ? * MON-FRI</code></td><td style="text-align:left">从周一到周五每天上午的10点15分触发</td></tr><tr><td><code>0 15 10 15 * ?</code></td><td style="text-align:left">每月15号上午10点15分触发</td></tr><tr><td><code>0 15 10 L * ?</code></td><td style="text-align:left">每月最后一天的10点15分触发</td></tr><tr><td><code>0 15 10 ? * 6L</code></td><td style="text-align:left">每月最后一周的星期五的10点15分触发</td></tr><tr><td><code>0 15 10 ? * 6L 2002-2005</code></td><td style="text-align:left">从2002年到2005年每月最后一周的星期五的10点15分触发</td></tr><tr><td><code>0 15 10 ? * 6#3</code></td><td style="text-align:left">每月的第三周的星期五开始触发</td></tr><tr><td><code>0 0 12 1/5 * ?</code></td><td style="text-align:left">每月的第一个中午开始每隔5天触发一次</td></tr><tr><td><code>0 11 11 11 11 ?</code></td><td style="text-align:left">每年的11月11号 11点11分触发(光棍节)</td></tr></tbody></table></div><p>​    Scheduler 负责管理Quartz的运行环境，Quartz 是基于多线程架构的，启动的时候会初始化一套线程，这套线程用来执行一些预置的作业。 Trigger和JobDetail可以注册到Scheduler中。Scheduler可以将Trigger绑定到某一JobDetail中，这样当Trigger触发时，对应的Job就会被执行。Scheduler拥有一个SchedulerContext，类似于ServletContext，保存着Scheduler上下文信息，Job 和 Trigger都可以访问SchedulerContext内的信息。Scheduler使用一个线程池作为任务的基础设施，任务通过共享线程池中的线程提高运行效率。</p><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.quartz-scheduler<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>quartz<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="定时器配置文件"><a href="#定时器配置文件" class="headerlink" title="定时器配置文件"></a>定时器配置文件</h3><p>​    创建定时器的方法有两种：1、使用XML配置文件的方式；2、使用注解的方式。</p><p>这里使用注解的方式使用定时器配置。</p><p>我们在/src/main/java/com.lpy.quartz目录下创建SendMailQuartz定时器类，具体代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendMailQuartz</span> </span>&#123;</span><br><span class="line">    <span class="comment">//日志对象</span></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LogManager.getLogger(SendMailQuartz<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每5秒执行一次</span></span><br><span class="line">    <span class="meta">@Scheduled</span>(cron = <span class="string">"*/5 * *  * * *"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reportCurrentByCron</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"定时器运行了！！！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>@Configurable: 加上此注解的类相当于XML配置文件，可以被Spring Boot扫描初始化。</li><li>@EnableScheduling：通过在配置类注解@EnableScheduling 来开启对计划任务的支持，然后在要执行计划任务的方法上注解@Scheduled，声明这是一个计划任务。</li><li>@Scheduled： 注解为定时任务，在cron表达式里写执行的时机。</li></ul><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>启动项目，查看控制台输出信息，发现每个5秒就打印指定的信息。则表示Quartz定时器设置成功。</p><p><img src="/2022/01/19/Quartz%E5%AE%9A%E6%97%B6%E5%99%A8%E5%92%8C%E5%8F%91%E9%80%81Email/image-20220119173655292.png" alt="image-20220119173655292"></p><h2 id="Spring-Boot发送Email"><a href="#Spring-Boot发送Email" class="headerlink" title="Spring Boot发送Email"></a>Spring Boot发送Email</h2><h3 id="Email介绍"><a href="#Email介绍" class="headerlink" title="Email介绍"></a>Email介绍</h3><p>邮件发送与接收的过程如下:</p><p>(1) 发件人使用SMTP协议传输邮件到邮件服务器A</p><p>(2) 邮件服务器A根据邮件中指定的接收者投送邮件至相应的邮件服务器B</p><p>(3) 收件人使用POP3协议从邮件服务器B接收邮件</p><p>SMTP 协议全称为 Simple Mail Transfer Protocol，译作简单邮件传输协议，它定义了邮件客户端软件与 SMTP 服务器之间，以及 SMTP 服务器与 SMTP 服务器之间的通信规则。</p><p>也就是说 aaa@qq.com 用户先将邮件投递到腾讯的 SMTP 服务器这个过程就使用了 SMTP 协议，然后腾讯的 SMTP 服务器将邮件投递到网易的 SMTP 服务器这个过程也依然使用了 SMTP 协议，SMTP 服务器就是用来收邮件。</p><p>而 POP3 协议全称为 Post Office Protocol ，译作邮局协议，它定义了邮件客户端与 POP3 服务器之间的通信规则，那么该协议在什么场景下会用到呢？当邮件到达网易的 SMTP 服务器之后， 111@163.com 用户需要登录服务器查看邮件，这个时候就该协议就用上了：邮件服务商都会为每一个用户提供专门的邮件存储空间，SMTP 服务器收到邮件之后，就将邮件保存到相应用户的邮件存储空间中，如果用户要读取邮件，就需要通过邮件服务商的 POP3 邮件服务器来完成。</p><h3 id="引入依赖-1"><a href="#引入依赖-1" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-mail<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="添加Email配置"><a href="#添加Email配置" class="headerlink" title="添加Email配置"></a>添加Email配置</h3><p>我们需要在application.yaml文件中添加如下配置信息:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### Mail邮件配置</span></span><br><span class="line">  <span class="comment">### 邮箱主机</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">mail:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">smtp.qq.com</span></span><br><span class="line">    <span class="comment">### 发送者邮箱</span></span><br><span class="line">    <span class="attr">username:</span> <span class="number">1234</span><span class="string">@qq.com</span></span><br><span class="line">    <span class="comment">### 设置的授权码</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">1234555</span></span><br><span class="line">    <span class="comment">### 默认编码</span></span><br><span class="line">    <span class="attr">default-encoding:</span> <span class="string">UTF-8</span></span><br><span class="line">    <span class="comment"># 配置SSL 加密工厂</span></span><br><span class="line">    <span class="attr">properties:</span></span><br><span class="line">      <span class="attr">mail:</span></span><br><span class="line">        <span class="attr">smtp:</span></span><br><span class="line">          <span class="attr">socketFactoryClass:</span> <span class="string">javax.net.ssl.SSLSocketFactory</span></span><br><span class="line">        <span class="comment">#表示开启 DEBUG 模式，这样，邮件发送过程的日志会在控制台打印出来，方便排查错误</span></span><br><span class="line">        <span class="attr">debug:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment">### 端口号465或587</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">587</span></span><br></pre></td></tr></table></figure><p><strong>126邮箱SMTP服务器地址:smtp.126.com,端口号:465或者994</strong><br><strong>2163邮箱SMTP服务器地址:smtp.163.com,端口号:465或者994</strong><br><strong>yeah邮箱SMTP服务器地址:smtp.yeah.net,端口号:465或者994</strong><br><strong>qq邮箱SMTP服务器地址：smtp.qq.com,端口号465或587*</strong></p><h3 id="在定时器中发送邮件"><a href="#在定时器中发送邮件" class="headerlink" title="在定时器中发送邮件"></a>在定时器中发送邮件</h3><p>​    在Spring Boot中添加完依赖和配置之后，我们在项目的目录/src/main/java/com.lpy.mail下新建邮件服务接口类SendJunkMailService，具体代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SendJunkMailService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">sendJunkMail</span><span class="params">(List&lt;AyUser&gt; ayUserList)</span> <span class="keyword">throws</span> MessagingException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后继续在项目的目录/src/main/java/com.lpy.mail下新建接口类的的实现类SendJunkMailServiceImpl.java，具体代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendJunkMailServiceImpl</span> <span class="keyword">implements</span> <span class="title">SendJunkMailService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    JavaMailSender mailSender;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> AyUserService ayUserService;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;spring.mail.username&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String from;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LogManager.getLogger(SendJunkMailServiceImpl<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendJunkMail</span><span class="params">(List&lt;AyUser&gt; ayUserList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(ayUserList == <span class="keyword">null</span> || ayUserList.size()&lt;=<span class="number">0</span>) <span class="keyword">return</span> Boolean.FALSE;</span><br><span class="line">        <span class="keyword">for</span> (AyUser ayUser:ayUserList) &#123;</span><br><span class="line">            MimeMessage mimeMessage = <span class="keyword">this</span>.mailSender.createMimeMessage();</span><br><span class="line">            MimeMessageHelper message = <span class="keyword">new</span> MimeMessageHelper(mimeMessage);</span><br><span class="line">            <span class="comment">//邮件发送方</span></span><br><span class="line">            message.setFrom(from);</span><br><span class="line">            message.setSubject(<span class="string">"哈哈，这是一个测试"</span>);</span><br><span class="line">            <span class="comment">//邮件接收方</span></span><br><span class="line">            message.setTo(<span class="string">"test@163.com"</span>);</span><br><span class="line">            message.setText(ayUser.getName()+<span class="string">",这是Mail测试"</span>);</span><br><span class="line">            <span class="keyword">this</span>.mailSender.send(mimeMessage);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            logger.error(<span class="string">"sendJunkMail error and ayUser=%s"</span>,ayUserList,ex);</span><br><span class="line">            <span class="keyword">return</span> Boolean.FALSE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Boolean.FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>@Value：可以将application.yaml配置文件中的配置设置到属性中。</li><li>JavaMailSender： 邮件发送接口。在Spring Boot 的Starter模块已为此提供了自动化配置，我们只需要通过注解@Autowired注入进来即可使用。</li></ul><p>现在我们重新修改SendMailQuartz定时器类，让定时器类能够每隔一段时间给数据库的用户发送广告邮件，SendMailQuartz类具体的修改如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendMailQuartz</span> </span>&#123;</span><br><span class="line">    <span class="comment">//日志对象</span></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LogManager.getLogger(SendMailQuartz<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> SendJunkMailService sendJunkMailService;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> AyUserService ayUserService;</span><br><span class="line">    <span class="comment">//每5秒执行一次</span></span><br><span class="line">    <span class="meta">@Scheduled</span>(cron = <span class="string">"*/5 * *  * * *"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reportCurrentByCron</span><span class="params">()</span> <span class="keyword">throws</span> MessagingException </span>&#123;</span><br><span class="line">        List&lt;AyUser&gt; userList = ayUserService.findAll();</span><br><span class="line">        <span class="keyword">if</span>(userList == <span class="keyword">null</span> || userList.size() &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//发送邮件</span></span><br><span class="line">        sendJunkMailService.sendJunkMail(userList);</span><br><span class="line">        logger.info(<span class="string">"定时器运行了！！！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><p>代码全部开发完成之后，重新启动项目，发送邮件定时器类SendMailQuartz，每隔5秒会查询数据库表ay_test中的所有用户，并发送广告邮件给对应的用户。我们登录对应接收用户邮箱发现如下信息:</p><p><img src="/2022/01/19/Quartz%E5%AE%9A%E6%97%B6%E5%99%A8%E5%92%8C%E5%8F%91%E9%80%81Email/image-20220119192604464.png" alt="image-20220119192604464"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Quartz定时器和发送Email&quot;&gt;&lt;a href=&quot;#Quartz定时器和发送Email&quot; class=&quot;headerlink&quot; title=&quot;Quartz定时器和发送Email&quot;&gt;&lt;/a&gt;Quartz定时器和发送Email&lt;/h1&gt;&lt;h2 id=&quot;使用Qua
      
    
    </summary>
    
    
      <category term="SpringBoot" scheme="https://tropical-forest.github.io/categories/SpringBoot/"/>
    
    
      <category term="Quartz定时器" scheme="https://tropical-forest.github.io/tags/Quartz%E5%AE%9A%E6%97%B6%E5%99%A8/"/>
    
      <category term="定时发送邮件" scheme="https://tropical-forest.github.io/tags/%E5%AE%9A%E6%97%B6%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>集成Log4j日志</title>
    <link href="https://tropical-forest.github.io/2022/01/19/%E9%9B%86%E6%88%90Log4j%E6%97%A5%E5%BF%97/"/>
    <id>https://tropical-forest.github.io/2022/01/19/%E9%9B%86%E6%88%90Log4j%E6%97%A5%E5%BF%97/</id>
    <published>2022-01-19T07:54:17.000Z</published>
    <updated>2022-01-19T07:56:39.405Z</updated>
    
    <content type="html"><![CDATA[<h1 id="集成Log4j日志"><a href="#集成Log4j日志" class="headerlink" title="集成Log4j日志"></a>集成Log4j日志</h1><h2 id="Log4j介绍"><a href="#Log4j介绍" class="headerlink" title="Log4j介绍"></a>Log4j介绍</h2><p>​    在应用程雪中添加日志记录有三个目的：</p><ol><li>监视代码中变量的变化情况，周期性地记录到文件中，供其他应用进行统计分析工作</li><li>跟踪代码运行时的轨迹，作为日后审计的依据</li><li>担当集成开发环境中调试器的作用，向文件或控制台打印代码的调试信息</li></ol><p>Log4j中有三个主要的组件，分别是Loggers(记录器)、Appenders（输出源）和Layouts(布局),这三个组件可以简单的理解为日志类别、日志要输出的地方和日志以哪种形式输出。</p><ul><li>Loggers(记录器):  Loggers组件被分为7个级别: all、debug、info、warn、error、fatal、off。这7个级别是有优先级的: all&lt;debug&lt;info&lt;warn&lt;error&lt;fatal&lt;off，分别用来指定这条日志信息的重要程度。Log4j有一个规则： 只输入级别不低于设定级别的日志信息。</li><li>Appenders（输出源)：Log4j日志系统允许把日志输出到不同的地方</li><li>Layouts(布局): Layout的作用是控制Log信息的输出方式</li></ul><p>​    Log4j支持两种配置文件格式，一种是XML格式的文件，一种是Java特性文件log4j2.properties。</p><p>具体XML配置如下:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Configuration</span> <span class="attr">status</span>=<span class="string">"WARN"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Appenders</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Console</span> <span class="attr">name</span> = <span class="string">"Console"</span><span class="attr">target</span>=<span class="string">"SYSTEM_OUT"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"%d&#123;HH:mm:ss:.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n"</span></span></span><br><span class="line">        &lt;/Console&gt;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">Appenders</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Loggers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Root</span> <span class="attr">level</span>=<span class="string">"debug"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">"Console"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Loggers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="集成Log4j2"><a href="#集成Log4j2" class="headerlink" title="集成Log4j2"></a>集成Log4j2</h2><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-log4j2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​    Spring Boot默认使用Logback日志框架来记录日志，并用INFO级别输出到控制台，所以我们在引入Log4j2之前，需要先排除该包的依赖，再引入Log4j2的依赖。</p><p>具体排除Logback依赖的代码如下:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="添加Log4j配置"><a href="#添加Log4j配置" class="headerlink" title="添加Log4j配置"></a>添加Log4j配置</h3><p>​    这里我们使用XML格式配置Log4j2，需要在application.yaml文件中添加如下配置信息即可:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">config:</span> <span class="string">log4j2.xml</span></span><br></pre></td></tr></table></figure><p>​     配置完成后，Spring Boot会在classpath路径下查找log4j2.xml，所以需要配置log4j2.xml文件即可</p><h3 id="创建log4j2-xml文件"><a href="#创建log4j2-xml文件" class="headerlink" title="创建log4j2.xml文件"></a>创建log4j2.xml文件</h3><p>在目录/src/main/resources下新建空的日志配置文件log4j2.xml</p><p>具体代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8" ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Configuration</span> <span class="attr">status</span>=<span class="string">"WARN"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Appenders</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Appenders</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Loggers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"all"</span>&gt;</span></span><br><span class="line">            </span><br><span class="line">        <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Loggers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="使用Log4j记录日志"><a href="#使用Log4j记录日志" class="headerlink" title="使用Log4j记录日志"></a>使用Log4j记录日志</h2><h3 id="打印到控制台"><a href="#打印到控制台" class="headerlink" title="打印到控制台"></a>打印到控制台</h3><p>​    现在我们把日志打印到控制台，需要往log4j2.xml配置文件中添加到相关的配置，具体代码如下:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Configuration</span> <span class="attr">status</span>=<span class="string">"WARN"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Appenders</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Console</span> <span class="attr">name</span> = <span class="string">"Console"</span><span class="attr">target</span>=<span class="string">"SYSTEM_OUT"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--指定日志的输出格式 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"%d&#123;HH:mm:ss:.SSS&#125; [%p] - %1 - %m%n"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Console</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Appenders</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Loggers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Root</span> <span class="attr">level</span>=<span class="string">"debug"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 控制台输出 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">"Console"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Loggers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><Console>：指定控制台输出</Console></li><li><PatternLayout>：控制日志的输出格式</PatternLayout></li></ul><p>之前我们开发的AyUserListener监听器是使用System.out.println()来打印信息，这是一种非常不合理的方式，现在我们把Logger类引入AyUserListener监听器中，同时把System.out.println相关代码注释掉，该吃日志方式记录信息。AyUserListener的具体代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AyUserListener</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AyUserService ayUserService;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">static</span> <span class="keyword">final</span> String ALL_USER = <span class="string">"ALL_USER_LIST"</span>;</span><br><span class="line">    <span class="comment">//需要添加的代码</span></span><br><span class="line">    Logger logger = LogManager.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent servletContextEvent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//查询数据库所有的用户</span></span><br><span class="line">        List&lt;AyUser&gt; ayUserList = ayUserService.findAll();</span><br><span class="line">        <span class="comment">// 清除缓存中的用户数据</span></span><br><span class="line">        redisTemplate.delete(ALL_USER);</span><br><span class="line">        <span class="comment">// 将数据存放到Redis缓存中</span></span><br><span class="line">        redisTemplate.opsForList().leftPushAll(ALL_USER, ayUserList);</span><br><span class="line">        <span class="comment">// 在真实项目中需要注释掉，查询所有的用户数据</span></span><br><span class="line">        List&lt;AyUser&gt; queryUserList = redisTemplate.opsForList().range(ALL_USER, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//System.out.println("缓存中目前的用户数有: " + queryUserList.size() + " 人 ");</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//System.out.println("ServletContext 上下文初始化 ");</span></span><br><span class="line">        logger.info(<span class="string">"ServletContext 上下文初始化 "</span>);</span><br><span class="line">        logger.info(<span class="string">"缓存中目前的用户数有: "</span> + queryUserList.size() + <span class="string">" 人 "</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent servletContextEvent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//System.out.println("ServletContext 上下文销毁");</span></span><br><span class="line">        logger.info(<span class="string">"ServletContext 上下文销毁"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="记录到文件"><a href="#记录到文件" class="headerlink" title="记录到文件"></a>记录到文件</h3><p>在上线环境中，项目的日志都是被记录到文件中的。所以我们继续在log4j2.xml配置文件中添加相关配置，使日志可以被打印到文件中，具体代码如下:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;!--日志级别以及优先级排序: OFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE &gt; ALL --&gt;</span><br><span class="line">&lt;!-- status log4j2内部日志级别 --&gt;</span><br><span class="line">&lt;configuration status=<span class="string">"INFO"</span>&gt;</span><br><span class="line">    &lt;!-- 全局参数 --&gt;</span><br><span class="line">    &lt;Properties&gt;</span><br><span class="line">        &lt;Property name="pattern"&gt;%d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; %-5p %c&#123;1&#125;:%L -%m%n&lt;/Property&gt;</span><br><span class="line">        &lt;Property name="displayName"&gt;EurekaServer&lt;/Property&gt;</span><br><span class="line">    &lt;/Properties&gt;</span><br><span class="line">    &lt;Appenders&gt;</span><br><span class="line">        &lt;Console name=<span class="string">"console"</span> target=<span class="string">"SYSTEM_OUT"</span> follow=<span class="string">"true"</span>&gt;</span><br><span class="line">            &lt;PatternLayout&gt;</span><br><span class="line">                &lt;pattern&gt;$&#123;pattern&#125;&lt;/pattern&gt;</span><br><span class="line">            &lt;/PatternLayout&gt;</span><br><span class="line">        &lt;/Console&gt;</span><br><span class="line">        &lt;!-- 文件 每次运行程序会自动清空，由append属性决定 --&gt;</span><br><span class="line">        &lt;File name=<span class="string">"error"</span> fileName=<span class="string">"$&#123;displayName&#125;_error.log"</span> append=<span class="string">"false"</span>&gt;</span><br><span class="line">            &lt;!-- 指定error 级别的日志 --&gt;</span><br><span class="line">            &lt;ThresholdFilter level=<span class="string">"ERROR"</span> onMatch=<span class="string">"ACCEPT"</span></span><br><span class="line">                             onMismatch=<span class="string">"DENY"</span> /&gt;</span><br><span class="line">            &lt;PatternLayout&gt;</span><br><span class="line">                &lt;pattern&gt;$&#123;pattern&#125;&lt;/pattern&gt;</span><br><span class="line">            &lt;/PatternLayout&gt;</span><br><span class="line">        &lt;/File&gt;</span><br><span class="line">        &lt;!-- 滚动文件 --&gt;</span><br><span class="line">        &lt;RollingFile name=<span class="string">"rollingFile"</span> fileName=<span class="string">"$&#123;displayName&#125;.log"</span></span><br><span class="line">                     filePattern=<span class="string">"$&#123;displayName&#125;_%d&#123;yyyy-MM-dd&#125;.log"</span>&gt;</span><br><span class="line">            &lt;PatternLayout&gt;</span><br><span class="line">                &lt;pattern&gt;$&#123;pattern&#125;&lt;/pattern&gt;</span><br><span class="line">            &lt;/PatternLayout&gt;</span><br><span class="line">            &lt;!-- 按大小划分 --&gt;</span><br><span class="line">            &lt;SizeBasedTriggeringPolicy size=<span class="string">"50 MB"</span> /&gt;</span><br><span class="line">        &lt;/RollingFile&gt;</span><br><span class="line">    &lt;/Appenders&gt;</span><br><span class="line">    &lt;Loggers&gt;</span><br><span class="line">        &lt;!-- &lt;Logger name=<span class="string">"org.apache.catalina.util.LifecycleBase"</span> level=<span class="string">"ERROR"</span></span><br><span class="line">            /&gt; &lt;Logger name=<span class="string">"org.apache.coyote.http11.Http11NioProtocol"</span> level=<span class="string">"WARN"</span></span><br><span class="line">            /&gt; &lt;Logger name=<span class="string">"org.apache.tomcat.util.net.NioSelectorPool"</span> level=<span class="string">"WARN"</span></span><br><span class="line">            /&gt; --&gt;</span><br><span class="line">        &lt;Logger name=<span class="string">"org.springframework"</span> level=<span class="string">"WARN"</span> /&gt;</span><br><span class="line">        &lt;Logger name=<span class="string">"com.lpy"</span> level=<span class="string">"DEBUG"</span> /&gt;</span><br><span class="line">        &lt;Root level=<span class="string">"DEBUG"</span>&gt;</span><br><span class="line">            &lt;AppenderRef ref="console"&gt;&lt;/AppenderRef&gt;</span><br><span class="line">            &lt;AppenderRef ref="error"&gt;&lt;/AppenderRef&gt;</span><br><span class="line">            &lt;AppenderRef ref="rollingFile"&gt;&lt;/AppenderRef&gt;</span><br><span class="line">        &lt;/Root&gt;</span><br><span class="line">    &lt;/Loggers&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><ul><li><RollingFile>标签: fileName用于定义日志的数据路径</RollingFile></li><li><Filters>标签: 日志过滤策略</Filters></li></ul><p>​    现在我们修改AyUserServiceImpl类的删除方法delete，希望删除用户这个操作可以被记录到日志文件中，AyUserServiceImpl类代码具体修改如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AyUserServiceImpl</span> <span class="keyword">implements</span> <span class="title">AyUserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//省略代码</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//需要添加的代码</span></span><br><span class="line">    Logger logger = LogManager.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ayUserRepository.deleteById(id);</span><br><span class="line">        logger.info(<span class="string">"userId:"</span>+id + <span class="string">"用户被删除"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//省略代码</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>​    代码开发完成后，开始测试工作。启动项目，然后在日志文件找到以前控制台输出的信息</p><p><img src="/2022/01/19/%E9%9B%86%E6%88%90Log4j%E6%97%A5%E5%BF%97/image-20220119155010289.png" alt="image-20220119155010289"></p><p>接下来再测试一下在删除用户的时候日志记录到日志文件中。在测试类中添加如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Logger logger = LogManager.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLog4j</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ayUserService.delete(<span class="string">"4"</span>);</span><br><span class="line">    logger.info(<span class="string">"delete success!!!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后在日志文件中找到“delete success”表示运用Log4j成功</p><p><img src="/2022/01/19/%E9%9B%86%E6%88%90Log4j%E6%97%A5%E5%BF%97/image-20220119155323549.png" alt="image-20220119155323549"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;集成Log4j日志&quot;&gt;&lt;a href=&quot;#集成Log4j日志&quot; class=&quot;headerlink&quot; title=&quot;集成Log4j日志&quot;&gt;&lt;/a&gt;集成Log4j日志&lt;/h1&gt;&lt;h2 id=&quot;Log4j介绍&quot;&gt;&lt;a href=&quot;#Log4j介绍&quot; class=&quot;he
      
    
    </summary>
    
    
      <category term="SpringBoot" scheme="https://tropical-forest.github.io/categories/SpringBoot/"/>
    
    
      <category term="Log4j" scheme="https://tropical-forest.github.io/tags/Log4j/"/>
    
      <category term="日志" scheme="https://tropical-forest.github.io/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>集成 Redis 缓存</title>
    <link href="https://tropical-forest.github.io/2022/01/19/%E9%9B%86%E6%88%90-Redis-%E7%BC%93%E5%AD%98/"/>
    <id>https://tropical-forest.github.io/2022/01/19/%E9%9B%86%E6%88%90-Redis-%E7%BC%93%E5%AD%98/</id>
    <published>2022-01-19T01:27:52.000Z</published>
    <updated>2022-01-19T01:31:57.749Z</updated>
    
    <content type="html"><![CDATA[<h1 id="集成-Redis-缓存"><a href="#集成-Redis-缓存" class="headerlink" title="集成 Redis 缓存"></a>集成 Redis 缓存</h1><h2 id="Redis-缓存介绍"><a href="#Redis-缓存介绍" class="headerlink" title="Redis 缓存介绍"></a>Redis 缓存介绍</h2><h3 id="Redis-概述"><a href="#Redis-概述" class="headerlink" title="Redis 概述"></a>Redis 概述</h3><ul><li>Redis 是一个基于内存的单线程高性能key-value 型数据库, 读写性能优异。</li><li>Redis 支持丰富的数据类型， 包括string(字符串)、list（链表)、set(集合)、zset（sorted set 有序集合）和 hash（哈希类型)。</li></ul><h3 id="Redis-服务器的安装"><a href="#Redis-服务器的安装" class="headerlink" title="Redis 服务器的安装"></a>Redis 服务器的安装</h3><p>​    下载网址是<a href="https://github.com/microsoftarchive/redis/releases" target="_blank" rel="noopener">https://github.com/microsoftarchive/redis/releases</a></p><p><img src="/2022/01/19/%E9%9B%86%E6%88%90-Redis-%E7%BC%93%E5%AD%98/image-20220118164440027.png" alt="image-20220118164440027"></p><p>把下载的包解压后的结构如下图所示:</p><p><img src="/2022/01/19/%E9%9B%86%E6%88%90-Redis-%E7%BC%93%E5%AD%98/image-20220118164537382.png" alt="image-20220118164537382"></p><p>运行上图中的redis-server.exe，同时，我们可以看到Redis 启动成功的界面，如下图所示:</p><p><img src="/2022/01/19/%E9%9B%86%E6%88%90-Redis-%E7%BC%93%E5%AD%98/image-20220118164704206.png" alt="image-20220118164704206"></p><h3 id="Redis-缓存测试"><a href="#Redis-缓存测试" class="headerlink" title="Redis 缓存测试"></a>Redis 缓存测试</h3><p>​        Redis 安装成功之后， 我们可以在安装包里找到 Redis 客户端程序 redis-cli.exe，运行该exe，打开Redis 客户端界面，如下图所示:</p><p><img src="/2022/01/19/%E9%9B%86%E6%88%90-Redis-%E7%BC%93%E5%AD%98/image-20220118164843626.png" alt="image-20220118164843626"></p><p>​    下面使用 Redis 客户端对 Redis 的几种数据类型做基本的增删改查操作练习，具体代码如下:</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line">字符串类型的增删改查</span><br><span class="line"></span><br><span class="line">### 增加一个值 key 为 name, value 为 ay</span><br><span class="line">127.0.0.1:6379&gt; set name 'ay'</span><br><span class="line">OK</span><br><span class="line">### 查询 name 的值</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line">"ay"</span><br><span class="line">### 更新 name 的值为 al</span><br><span class="line">127.0.0.1:6379&gt; set name 'al'</span><br><span class="line">OK</span><br><span class="line">### 查询 name 的值</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line">"al"</span><br><span class="line">### 删除 name 的值</span><br><span class="line">127.0.0.1:6379&gt; del name</span><br><span class="line">(integer) 1</span><br><span class="line">### 查询是否存在 name, 0 代表不存在</span><br><span class="line">127.0.0.1:6379&gt; exists name</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">List 集合的增删改查:</span><br><span class="line"></span><br><span class="line">### 添加 key 为 user_list, value为'ay','al'的list集合</span><br><span class="line">127.0.0.1:6379&gt; lpush user_list 'ay' 'al'</span><br><span class="line">(integer) 2</span><br><span class="line">### 查询 key为user_list的集合</span><br><span class="line">127.0.0.1:6379&gt; lrange user_list 0 -1</span><br><span class="line">1) "al"</span><br><span class="line">2) "ay"</span><br><span class="line">### 往list尾部添加love元素</span><br><span class="line">127.0.0.1:6379&gt; rpush user_list 'love'</span><br><span class="line">(integer) 3</span><br><span class="line">### 往list头部添加hope元素</span><br><span class="line">127.0.0.1:6379&gt; lpush user_list 'hope'</span><br><span class="line">(integer) 4</span><br><span class="line">### 查询key 为user_list的集合</span><br><span class="line">127.0.0.1:6379&gt; lrange user_list 0 -1</span><br><span class="line">1) "hope"</span><br><span class="line">2) "al"</span><br><span class="line">3) "ay"</span><br><span class="line">4) "love"</span><br><span class="line">### 更新index为0的值</span><br><span class="line">127.0.0.1:6379&gt; lset user_list 0 'wish'</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">### 查询key 为user_list的集合</span><br><span class="line">127.0.0.1:6379&gt; lrange user_list 0 -1</span><br><span class="line">1) "wish"</span><br><span class="line">2) "al"</span><br><span class="line">3) "ay"</span><br><span class="line">4) "love"</span><br><span class="line">### 删除index为0的值</span><br><span class="line">127.0.0.1:6379&gt; lrem user_list 0 'wish'</span><br><span class="line">(integer) 1</span><br><span class="line">### 查询key 为user_list的集合</span><br><span class="line">127.0.0.1:6379&gt; lrange user_list 0 -1</span><br><span class="line">1) "al"</span><br><span class="line">2) "ay"</span><br><span class="line">3) "love"</span><br><span class="line"></span><br><span class="line">Set集合的增删改查:</span><br><span class="line"></span><br><span class="line">### 添加key为user_set,value为"ay" "al" "love"的集合</span><br><span class="line">127.0.0.1:6379&gt; sadd user_set "ay" "al" "love"</span><br><span class="line">(integer) 3</span><br><span class="line">### 查询key为user_set的集合</span><br><span class="line">127.0.0.1:6379&gt; smembers user_set</span><br><span class="line">1) "al"</span><br><span class="line">2) "ay"</span><br><span class="line">3) "love"</span><br><span class="line">### 删除value为love，返回1表示删除成功，0表示失败</span><br><span class="line">127.0.0.1:6379&gt; srem user_set 'love'</span><br><span class="line">(integer) 1</span><br><span class="line">### 查询set集合所有值</span><br><span class="line">127.0.0.1:6379&gt; smembers user_set</span><br><span class="line">1) "al"</span><br><span class="line">2) "ay"</span><br><span class="line">### 添加love元素，set集合是没有顺序的，所以无法判断添加到哪个位置</span><br><span class="line">127.0.0.1:6379&gt; sadd user_set 'love'</span><br><span class="line">(integer) 1</span><br><span class="line">### 查询set集合所有的值，发现添加到第3个位置</span><br><span class="line">127.0.0.1:6379&gt; smembers user_set</span><br><span class="line">1) "al"</span><br><span class="line">2) "ay"</span><br><span class="line">3) "love"</span><br><span class="line">### 添加love元素， set集合已经存在， 返回0代表添加不成功，但是不会报错</span><br><span class="line">127.0.0.1:6379&gt; sadd user_set 'love'</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">Hash集合的增删改查</span><br><span class="line"></span><br><span class="line">### 清除数据库</span><br><span class="line">127.0.0.1:6379&gt; flushdb</span><br><span class="line">OK</span><br><span class="line">### 创建hash，key为user_hset，字段为user1，值为ay</span><br><span class="line">127.0.0.1:6379&gt; hset user_hset "user1" "ay"</span><br><span class="line">(integer) 1</span><br><span class="line">### 往key为user_hset的哈希集合添加字段为user2, 值为al</span><br><span class="line">127.0.0.1:6379&gt; hset user_hset "user2" "al"</span><br><span class="line">(integer) 1</span><br><span class="line">### 查询user_hset字段长度</span><br><span class="line">127.0.0.1:6379&gt; hlen user_hset</span><br><span class="line">(integer) 2</span><br><span class="line">### 查询user_hset所有字段</span><br><span class="line">127.0.0.1:6379&gt; hkeys user_hset</span><br><span class="line">1) "user1"</span><br><span class="line">2) "user2"</span><br><span class="line">### 查询user_hset所有值</span><br><span class="line">127.0.0.1:6379&gt; hvals user_hset</span><br><span class="line">1) "ay"</span><br><span class="line">2) "al"</span><br><span class="line">### 查询字段user1的值</span><br><span class="line">127.0.0.1:6379&gt; hget user_hset "user1"</span><br><span class="line">"ay"</span><br><span class="line">### 获取key为user_hset的哈希集合的所有字段和值</span><br><span class="line">127.0.0.1:6379&gt; hgetall user_hset</span><br><span class="line">1) "user1"</span><br><span class="line">2) "ay"</span><br><span class="line">3) "user2"</span><br><span class="line">4) "al"</span><br><span class="line">### 更新字段user1的值为new_ay</span><br><span class="line">127.0.0.1:6379&gt; hset user_hset "user1" "new_ay"</span><br><span class="line">(integer) 0</span><br><span class="line">### 更新字段user2的值new_al</span><br><span class="line">127.0.0.1:6379&gt; hset user_hset "user2" "new_al"</span><br><span class="line">(integer) 0</span><br><span class="line">### 获取key为user_hset的哈希集合的所有字段和值</span><br><span class="line">127.0.0.1:6379&gt; hgetall user_hset</span><br><span class="line">1) "user1"</span><br><span class="line">2) "new_ay"</span><br><span class="line">3) "user2"</span><br><span class="line">4) "new_al"</span><br><span class="line">### 删除字段user1和值</span><br><span class="line">127.0.0.1:6379&gt; hdel user_hset user1</span><br><span class="line">(integer) 1</span><br><span class="line">### 获取key为user_hset的哈希集合的所有字段和值</span><br><span class="line">127.0.0.1:6379&gt; hgetall user_hset</span><br><span class="line">1) "user2"</span><br><span class="line">2) "new_al"</span><br><span class="line"></span><br><span class="line">SortedSet集合的增删改查:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 清除数据库</span><br><span class="line">127.0.0.1:6379&gt; flushdb</span><br><span class="line">OK</span><br><span class="line">### 为SortedSet集合添加ay元素, 分数为1</span><br><span class="line">127.0.0.1:6379&gt; zadd user_zset 1 "ay"</span><br><span class="line">(integer) 1</span><br><span class="line">### 为SortedSet集合添加al元素， 分数为2</span><br><span class="line">127.0.0.1:6379&gt; zadd user_zset 2 "al"</span><br><span class="line">(integer) 1</span><br><span class="line">### 为SortedSet集合添加到love元素， 分数为3</span><br><span class="line">127.0.0.1:6379&gt; zadd user_zset 3 "love"</span><br><span class="line">(integer) 1</span><br><span class="line">### 按照分数由小到大查询user_zset集合的元素</span><br><span class="line">127.0.0.1:6379&gt; zrange user_zset 0 -1</span><br><span class="line">1) "ay"</span><br><span class="line">2) "al"</span><br><span class="line">3) "love"</span><br><span class="line">### 按照分数由大到小查询user_zset集合的元素</span><br><span class="line">127.0.0.1:6379&gt; zrevrange user_zset  0 -1</span><br><span class="line">1) "love"</span><br><span class="line">2) "al"</span><br><span class="line">3) "ay"</span><br><span class="line">### 查询元素ay的分数值</span><br><span class="line">127.0.0.1:6379&gt; zscore user_zset "ay"</span><br><span class="line">"1"</span><br><span class="line">### 查询元素love的分数值</span><br><span class="line">127.0.0.1:6379&gt; zscore user_zset "love"</span><br><span class="line">"3"</span><br></pre></td></tr></table></figure><h2 id="Spring-Boot集成Redis缓存"><a href="#Spring-Boot集成Redis缓存" class="headerlink" title="Spring Boot集成Redis缓存"></a>Spring Boot集成Redis缓存</h2><h3 id="Spring-Boot-缓存支持"><a href="#Spring-Boot-缓存支持" class="headerlink" title="Spring Boot 缓存支持"></a>Spring Boot 缓存支持</h3><p>​    在Spring Boot 中提供了强大的基于注解的缓存支持，可以通过注解配置方式低侵入地给原有Spring应用增加缓存功能，提高数据访问性能。</p><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="添加缓存配置"><a href="#添加缓存配置" class="headerlink" title="添加缓存配置"></a>添加缓存配置</h3><p>​    引入依赖后，需要在application.yaml文件中添加配置信息，如下所示:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### redis缓存配置</span></span><br><span class="line">  <span class="comment">### 默认 redis 缓存数据库为db0</span></span><br><span class="line"><span class="attr">Spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span></span><br><span class="line">    <span class="comment">### 服务器地址,默认为localhost</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="comment">### 链接端口，默认是6379</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">### redis默认密码为空</span></span><br><span class="line">    <span class="attr">password:</span></span><br></pre></td></tr></table></figure><h3 id="测试用例开发"><a href="#测试用例开发" class="headerlink" title="测试用例开发"></a>测试用例开发</h3><p>​    在测试类中添加如下代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRedis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//增 key：name,value:ay</span></span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">"name"</span>,<span class="string">"ay"</span>);</span><br><span class="line">    String name = (String)redisTemplate.opsForValue().get(<span class="string">"name"</span>);</span><br><span class="line">    System.out.println(name);</span><br><span class="line">    <span class="comment">//删除</span></span><br><span class="line">    redisTemplate.delete(<span class="string">"name"</span>);</span><br><span class="line">    <span class="comment">//更新</span></span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">"name"</span>,<span class="string">"al"</span>);</span><br><span class="line">    <span class="comment">//查询</span></span><br><span class="line">    name = stringRedisTemplate.opsForValue().get(name);</span><br><span class="line">    System.out.println(name);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    RedisTemplate 和 StringRedisTemplate都是 Spring Data Redis 为我们提供的模板类，用来对数据进行操作，其中StringRedisTemplate只针对键值是字符串的数据进行操作。在启用启动的时候，Spring 会为我们初始化这两个模板类，通过@Resource注解注入即可使用。</p><p>​    RedisTemplate 和 StringRedisTemplate除了提供opsForValue方法用来操作简单属性数据之外，还提供了以下数据访问方法。</p><p>​    （1）opsForList: 操作含有list的数据</p><p>​    （2)  opsForSet: 操作含有set的数据</p><p>​    （3） opsForZSet：操作含有ZSet的数据</p><p>​    （4） opsForHash： 操作含有hash的数据</p><p>​    当我们的数据存放到Redis的时候，键 和 值都是通过Spring提供的Serializer序列化到数据库的。RedisTemplate默认使用JdkSerializationRedisSerializer，而StringRedisTemplate默认使用StringRedisSerializer</p><p>所以需要使用StringRedisSerializer来序列化和反序列化redis的key值。这里需要用RedisConfig类。</p><p>​    在项目src/main/java/com/lpy/config/下创建RedisConfig.java,其详细代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        RedisTemplate template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        template.setConnectionFactory(connectionFactory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用Jackson2JsonRedisSerializer来序列化和反序列化redis的value值</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        Jackson2JsonRedisSerializer serializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer(Object<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">        mapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line"></span><br><span class="line">        mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line"></span><br><span class="line">        serializer.setObjectMapper(mapper);</span><br><span class="line"></span><br><span class="line">        template.setValueSerializer(serializer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用StringRedisSerializer来序列化和反序列化redis的key值</span></span><br><span class="line"></span><br><span class="line">        template.setKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*hash字符串序列化方法*/</span></span><br><span class="line">        template.setHashKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line">        template.setHashValueSerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line"></span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有使用StringRedisSerializer反序列redis的值，就会出现下面错误:</p><p><img src="/2022/01/19/%E9%9B%86%E6%88%90-Redis-%E7%BC%93%E5%AD%98/image-20220118224235855.png" alt="image-20220118224235855"></p><p>插入的值为乱码</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>运行上面的单元测试用例，我们可以在RedisDesktopManager 客户端工具查看Redis缓存数据库的数据。如下图所示:</p><p><img src="/2022/01/19/%E9%9B%86%E6%88%90-Redis-%E7%BC%93%E5%AD%98/image-20220118224541916.png" alt="image-20220118224541916"></p><h2 id="Redis-缓存在-Spring-Boot中使用"><a href="#Redis-缓存在-Spring-Boot中使用" class="headerlink" title="Redis 缓存在 Spring Boot中使用"></a>Redis 缓存在 Spring Boot中使用</h2><h3 id="监听器-Listener-的开发"><a href="#监听器-Listener-的开发" class="headerlink" title="监听器 Listener 的开发"></a>监听器 Listener 的开发</h3><p>​    在上下文初始化的方法中加载数据库中的所有用户数据，并存放到Redis缓存中。为什么要把用户的数据放在缓存中，因为用户的数据属于变动不大的数据，适合放在缓存中，这样在应用需要获取用户数据时，可以直接到Redis缓存中的数据获取，不用到数据库中获取数据库连接查询数据，提高数据访问的速度。</p><p>AyUserListener监听类的具体代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AyUserListener</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AyUserService ayUserService;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">static</span> <span class="keyword">final</span> String ALL_USER = <span class="string">"ALL_USER_LIST"</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent servletContextEvent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//查询数据库所有的用户</span></span><br><span class="line">        List&lt;AyUser&gt; ayUserList = ayUserService.findAll();</span><br><span class="line">        <span class="comment">// 清除缓存中的用户数据</span></span><br><span class="line">        redisTemplate.delete(ALL_USER);</span><br><span class="line">        <span class="comment">// 将数据存放到Redis缓存中</span></span><br><span class="line">        redisTemplate.opsForList().leftPushAll(ALL_USER, ayUserList);</span><br><span class="line">        <span class="comment">// 在真实项目中需要注释掉，查询所有的用户数据</span></span><br><span class="line">        List&lt;AyUser&gt; queryUserList = redisTemplate.opsForList().range(ALL_USER, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">"缓存中目前的用户数有: "</span> + queryUserList.size() + <span class="string">" 人 "</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"ServletContext 上下文初始化 "</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent servletContextEvent)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ServletContext 上下文销毁"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我这里的springboot的版本号是2.6，在上面监听类中如果使用@WebListener注解的话，ayUserService就无法装载进去，所以这里我用@Component来代替。</p><p>redisTemplate.opsForList().leftPushAll: 查询缓存中所有的用户数据，若ALL_USER键不存在，则会创建该键及与其关联的LIst,之后再将参数中的ayUserList从左到右依次插入。</p><p>redisTemplate.opsForList().range: 取链表中的全部元素，其中0表示第一个元素，-1表示最后一个元素。</p><p>​    当我们的数据存放到Redis的时候，键和值都是通过Spring提供的Serializer序列化到数据库的。RedisTemplate默认使用jdkSerializationRedisSerializer，而StringRedisTemplate默认使用StringRedisSerializer.所以我们需要让用户类AyUser实现序列化接口Serializable，具体代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AyUser</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="项目启动缓存数据"><a href="#项目启动缓存数据" class="headerlink" title="项目启动缓存数据"></a>项目启动缓存数据</h3><p>AyUserListener监听类和AyUser用户类已经开发好了，重新启动项目，这时数据库ay_user中的所有数据都会价值到Redis缓存中。在contextInitialized方法中断点调试，出现下图效果:</p><p><img src="/2022/01/19/%E9%9B%86%E6%88%90-Redis-%E7%BC%93%E5%AD%98/image-20220119091412562.png" alt="image-20220119091412562"></p><h3 id="更新缓存数据"><a href="#更新缓存数据" class="headerlink" title="更新缓存数据"></a>更新缓存数据</h3><p>​        项目启动并加载所有用户数据到缓存之后，我们需要修改AyUserServiceImpl中的接口，比如findById,save、delete等方法。如果在Redis缓存中查询不到数据，我们就需要用到数据库查询，如果能够在数据中查询到数据，除了返回数据之外，还需要把数据更新到缓存中。这样再次查询数据时，就不需要到数据库中查询数据了。这里以findById为例进行修改。</p><p>AyUserServicelmpl具体代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//省略代码</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AyUserServiceImpl</span> <span class="keyword">implements</span> <span class="title">AyUserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AyUserRepository ayUserRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">static</span> <span class="keyword">final</span> String ALL_USER = <span class="string">"ALL_USER_LIST"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AyUser <span class="title">findById</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//step.1 查询Redis缓存中的所有数据</span></span><br><span class="line">        List&lt;AyUser&gt; ayUserList = redisTemplate.opsForList().range(ALL_USER, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(ayUserList != <span class="keyword">null</span> &amp;&amp; ayUserList.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (AyUser user: ayUserList) &#123;</span><br><span class="line">                <span class="keyword">if</span>(user.getId().equals(id)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> user;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//step.2 查询数据库中的数据</span></span><br><span class="line">        AyUser ayUser = ayUserRepository.findById(id).orElse(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span>(ayUser != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//step.3 将数据插入Redis缓存中</span></span><br><span class="line">            redisTemplate.opsForList().leftPush(ALL_USER, ayUser);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ayUser;</span><br><span class="line">        <span class="comment">//return ayUserRepository.findById(id).orElse(null);</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于save、delete等方法的修改，思路是一样的。虽然引入Redis缓存用户数据可以提供访问性能，但是带来的代码复杂度也是很大的。所以不能滥用缓存。</p><h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><p>在测试类中添加如下测试方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindById</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Long redisUserSize = <span class="number">0L</span>;</span><br><span class="line">    <span class="comment">// 查询id=1的数据, 该数据存在于Redis缓存中</span></span><br><span class="line">    AyUser ayUser = ayUserService.findById(<span class="string">"1"</span>);</span><br><span class="line">    redisUserSize = redisTemplate.opsForList().size(<span class="string">"ALL_USER_LIST"</span>);</span><br><span class="line">    System.out.println(<span class="string">"目前缓存中的用户数量为： "</span> + redisUserSize);</span><br><span class="line">    System.out.println(<span class="string">"----&gt;&gt;&gt;id: "</span> + ayUser.getId() + <span class="string">"name:"</span> + ayUser.getName());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询id = 2 的数据,该数据存在于Redis缓存中</span></span><br><span class="line">    AyUser ayUser1 = ayUserService.findById(<span class="string">"2"</span>);</span><br><span class="line">    redisUserSize = redisTemplate.opsForList().size(<span class="string">"ALL_USER_LIST"</span>);</span><br><span class="line">    System.out.println(<span class="string">"目前缓存中的用户数量为： "</span> + redisUserSize);</span><br><span class="line">    System.out.println(<span class="string">"----&gt;&gt;&gt;id: "</span> + ayUser1.getId() + <span class="string">"name:"</span> + ayUser1.getName());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询id=4的数据，不存在于Redis缓存中，存在于数据库中</span></span><br><span class="line">    <span class="comment">//所以会把在数据库中查询的数据更新到缓存中</span></span><br><span class="line">    AyUser ayUser3 = ayUserService.findById(<span class="string">"4"</span>);</span><br><span class="line">    System.out.println(<span class="string">"----&gt;&gt;&gt;id: "</span> + ayUser3.getId() + <span class="string">"name:"</span> + ayUser3.getName());</span><br><span class="line">    redisUserSize = redisTemplate.opsForList().size(<span class="string">"ALL_USER_LIST"</span>);</span><br><span class="line">    System.out.println(<span class="string">"目前缓存中的用户数量为： "</span> + redisUserSize);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    代码开发完成后，重新启动项目，数据库中的3条数据会重新被添加到Redis缓存中。如下图所示</p><p><img src="/2022/01/19/%E9%9B%86%E6%88%90-Redis-%E7%BC%93%E5%AD%98/image-20220119092411274.png" alt="image-20220119092411274"></p><p>项目启动成功后，我们往数据库表ay_user添加id为4的第四条数据，最后执行单元测试方法testFindById(),在IDEA的控制台打印的信息如下:</p><p><img src="/2022/01/19/%E9%9B%86%E6%88%90-Redis-%E7%BC%93%E5%AD%98/image-20220119092622014.png" alt="image-20220119092622014"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;集成-Redis-缓存&quot;&gt;&lt;a href=&quot;#集成-Redis-缓存&quot; class=&quot;headerlink&quot; title=&quot;集成 Redis 缓存&quot;&gt;&lt;/a&gt;集成 Redis 缓存&lt;/h1&gt;&lt;h2 id=&quot;Redis-缓存介绍&quot;&gt;&lt;a href=&quot;#Redis-缓
      
    
    </summary>
    
    
      <category term="SpringBoot" scheme="https://tropical-forest.github.io/categories/SpringBoot/"/>
    
    
      <category term="Redis" scheme="https://tropical-forest.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>使用过滤器和监听器</title>
    <link href="https://tropical-forest.github.io/2022/01/18/%E4%BD%BF%E7%94%A8%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E7%9B%91%E5%90%AC%E5%99%A8/"/>
    <id>https://tropical-forest.github.io/2022/01/18/%E4%BD%BF%E7%94%A8%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E7%9B%91%E5%90%AC%E5%99%A8/</id>
    <published>2022-01-18T05:15:38.000Z</published>
    <updated>2022-01-18T05:19:28.137Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用过滤器和监听器"><a href="#使用过滤器和监听器" class="headerlink" title="使用过滤器和监听器"></a>使用过滤器和监听器</h1><h2 id="Sprin-Boot-使用过滤器-Filter"><a href="#Sprin-Boot-使用过滤器-Filter" class="headerlink" title="Sprin Boot 使用过滤器 Filter"></a>Sprin Boot 使用过滤器 Filter</h2><h3 id="过滤器-Filter-介绍"><a href="#过滤器-Filter-介绍" class="headerlink" title="过滤器 Filter 介绍"></a>过滤器 Filter 介绍</h3><ul><li>Filter 也称为过滤器，是处于客户端与服务器资源文件之间的一道过滤网</li><li>Web开发人员通过Filter技术管理Web服务器的所有资源</li><li>Filter 可以实现URL 级别的权限访问控制、过滤敏感词汇、压缩响应信息等功能</li></ul><p>​    Filter 的创建和销毁有Web服务器负责。Web应用程序启动时，Web服务器将创建Filter的实例对象，并调用其init方法，读取web.xml，完成对象的初始化功能，从而为后续的用户请求做好拦截的准备工作（Filter 对象只会创建一次，init方法也只会执行一次）。开发人员通过init 方法的参数可获得当前filter配置信息的 FilterConfig 对象</p><p>​    当客户请求访问与过滤器关联的URL时，过滤器将先执行doFilter方法，FilterChain参数用于访问后续过滤器。Filter 对象创建后会驻留在内存中，当Web应用移除或服务器停止时才销毁。在Web容器卸载Filter对象之前，destory被调用。该方法在Filter的声明周期中仅执行一次。</p><p>​    Filter可以有很多个，一个个Filter组合起来就形成一个FilterChain,也就是过滤链，如下图所示:</p><p><img src="/2022/01/18/%E4%BD%BF%E7%94%A8%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E7%9B%91%E5%90%AC%E5%99%A8/image-20220118114936086.png" alt="image-20220118114936086"></p><h3 id="过滤器-Filter-的使用"><a href="#过滤器-Filter-的使用" class="headerlink" title="过滤器 Filter 的使用"></a>过滤器 Filter 的使用</h3><p>​    在项目的目录/src/main/java/com.lpy.filter下新建AyUserFilter.java类，具体代码如下所示:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter</span>(filterName = <span class="string">"ayUserFilter"</span>, urlPatterns = <span class="string">"/*"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AyUserFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        <span class="comment">//Filter.super.init(filterConfig);</span></span><br><span class="line">        System.out.println(<span class="string">"-----------&gt;&gt;&gt; init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"-------------------------&gt;&gt;&gt; doFilter"</span>);</span><br><span class="line">        filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Filter.super.destroy();</span></span><br><span class="line">        System.out.println(<span class="string">"----------------&gt;&gt;&gt; destory"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@WebFilter: 用于将一个类声明为过滤器，该注解将会在应用部署时被容器处理。</p><p>​    AyUserFilter.java类开发完成之后，我们需要在入口类SpringbootDruidApplication.java中添加注解@ServletComponentScan，具体代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@ServletComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringbootDruidApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringbootDruidApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@ServletComponentScan：使用该注解后，Servlet、Filter、Listener可以通过@WebServlet、@WebFilter、@WebListener注解自动注册。</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>​    重新启动运行项目时，web容器会初始化AyUserFilter对象，并调用init方法，可以在后台看到打印信息，如下所示:</p><p><img src="/2022/01/18/%E4%BD%BF%E7%94%A8%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E7%9B%91%E5%90%AC%E5%99%A8/image-20220118122022796.png" alt="image-20220118122022796"></p><p>在浏览器中输入<a href="http://localhost:8080/ayUser/test" target="_blank" rel="noopener">http://localhost:8080/ayUser/test</a> 访问应用是，AyUserFilter 拦截器会拦截本次的请求，并调用 doFilter方法，同时会在控制台打印信息，如下图所示:</p><p><img src="/2022/01/18/%E4%BD%BF%E7%94%A8%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E7%9B%91%E5%90%AC%E5%99%A8/image-20220118122301279.png" alt="image-20220118122301279"></p><h2 id="Spring-Boot-使用监听器-Listener"><a href="#Spring-Boot-使用监听器-Listener" class="headerlink" title="Spring Boot 使用监听器 Listener"></a>Spring Boot 使用监听器 Listener</h2><h3 id="监听器-Listener-介绍"><a href="#监听器-Listener-介绍" class="headerlink" title="监听器 Listener 介绍"></a>监听器 Listener 介绍</h3><p>​    监听器也叫 Listener, 是Servlet的监听器， 可以用于监听Web应用中某些对象、信息的创建、销毁、增加、修改、删除等动作的发生， 然后作出相应的响应处理。监听器常用于统计在线人数和在线用户，系统加载时进行信息初始化、统计网站的访问量等。</p><p>​    根据监听对象可以把监听器分为3类: ServletContext、HttpSession、ServletRequest。Application 在整个Web服务中只有一个，在 Web 服务关闭时销毁。</p><p>​    Session对于每个会话，在会话起始时创建， 一端关闭会话时销毁。 Request 对象是客户发生请求时创建的，用于封装请求数据， 在一次请求处理完毕时销毁。</p><p>根据监听的事件， 可把监听器分为以下3类:</p><p>（1）监听对象创建和销毁, 如ServletContextListener</p><p>（2）监听对象域中属性的增加和删除，如 HttpSessionListener 和 ServletRequestListener.</p><p>（3）监听绑定到Session 上的某个对象的状态， 如 ServletContextAttributeListener、HttpSessionAttributeListener、ServletRequestAttributeListeener等</p><h3 id="监听器-Listener-的使用"><a href="#监听器-Listener-的使用" class="headerlink" title="监听器 Listener 的使用"></a>监听器 Listener 的使用</h3><p>​    在项目目录下/src/main/java/com.lpy.listener 下新建 AyUserListener.java 类，具体代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebListener</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AyUserListener</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent servletContextEvent)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ServletContext 上下文初始化 "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent servletContextEvent)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ServletContext 上下文销毁"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@WebListener:  用于将一个类声明为监听器</p><p>@ServletContextListener 类:  能够监听 ServletContext 对象的生命周期， 实际上就是监听 Web 应用的生命周期。</p><p>contextInitialized 方法: 当 Servlet 容器启动Web应用时调用该方法。</p><p>contextDestroyed 方法： 当 servlet 容器终止 Web 应用时调用该方法。</p><h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><p>重新启动运行项目，Web容器会初始化 AyUserListener 对象， 并调用contextInitialized 方法；当销毁时，会调用 contextDestroyed 方法。 如下图所示:</p><p><img src="/2022/01/18/%E4%BD%BF%E7%94%A8%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E7%9B%91%E5%90%AC%E5%99%A8/image-20220118131443279.png" alt="image-20220118131443279"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;使用过滤器和监听器&quot;&gt;&lt;a href=&quot;#使用过滤器和监听器&quot; class=&quot;headerlink&quot; title=&quot;使用过滤器和监听器&quot;&gt;&lt;/a&gt;使用过滤器和监听器&lt;/h1&gt;&lt;h2 id=&quot;Sprin-Boot-使用过滤器-Filter&quot;&gt;&lt;a href=&quot;#Sp
      
    
    </summary>
    
    
      <category term="SpringBoot" scheme="https://tropical-forest.github.io/categories/SpringBoot/"/>
    
    
      <category term="过滤器" scheme="https://tropical-forest.github.io/tags/%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    
      <category term="监听器" scheme="https://tropical-forest.github.io/tags/%E7%9B%91%E5%90%AC%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Spring 事务支持</title>
    <link href="https://tropical-forest.github.io/2022/01/18/Spring-%E4%BA%8B%E5%8A%A1%E6%94%AF%E6%8C%81/"/>
    <id>https://tropical-forest.github.io/2022/01/18/Spring-%E4%BA%8B%E5%8A%A1%E6%94%AF%E6%8C%81/</id>
    <published>2022-01-18T01:42:08.000Z</published>
    <updated>2022-01-18T01:49:46.473Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-Boot-事务支持"><a href="#Spring-Boot-事务支持" class="headerlink" title="Spring Boot 事务支持"></a>Spring Boot 事务支持</h1><h2 id="Spring-事务"><a href="#Spring-事务" class="headerlink" title="Spring 事务"></a>Spring 事务</h2><h3 id="Spring-事务介绍"><a href="#Spring-事务介绍" class="headerlink" title="Spring 事务介绍"></a>Spring 事务介绍</h3><ul><li>事务有四大特性: 原子性、一致性、隔离性和持久性</li><li>事务管理是用来确保数据的完整性和一致性</li><li>Spring既支持编程式事务管理（也称编码式事务），又支持声明式事务管理</li><li>编程式事务管理是指将事务管理代码嵌入业务方法中来控制事务的提交和回滚。在编程式事务中，必须在每个业务操作中包含额外的事务管理代码</li><li>声明式事务管理是指将事务管理代码从业务中分离出来，以声明的方式来实现事务管理。</li><li>Spring通过Spring AOP框架支持声明式事务管理</li><li>面对众多的数据访问技术，Spring在不同的事务管理API上定义了一个抽象层Platform Transaction-Manager,应用程序开发人员不必了解底层的事务管理API就可以使用Spring的事务管理机制</li></ul><h3 id="Spring-声明式事务"><a href="#Spring-声明式事务" class="headerlink" title="Spring 声明式事务"></a>Spring 声明式事务</h3><ul><li>Spring 配置文件中关于事务配置总是由三部分组成，分别是 DataSource、TransactionManager和代理机制</li><li>无论哪种配置方式，一般变化的只是代理机制部分，DataSource 和 TransactionManager 这两部分只会根据数据访问方式有所变化</li><li>Spring 声明式事务配置提供5中方式，而基于Annotation的注解方式目前比较流行</li><li>在基于注解方式配置Spring声明式服务时，我们可以使用@Transactional注解在类或者方法中表明该类或者方法需要事务支持。</li></ul><h3 id="Spring-注解事务行为"><a href="#Spring-注解事务行为" class="headerlink" title="Spring 注解事务行为"></a>Spring 注解事务行为</h3><p>常用的事务传播行为如下：</p><ul><li>PROPAGATION_REQUIRED<br>Spring默认的传播机制，能满足绝大部分业务需求，如果外层有事务，则当前事务加入到外层事务，一块提交，一块回滚。如果外层没有事务，新建一个事务执行</li><li>PROPAGATION_REQUES_NEW<br>该事务传播机制是每次都会新开启一个事务，同时把外层事务挂起，当当前事务执行完毕，恢复上层事务的执行。如果外层没有事务，执行当前新开启的事务即可</li><li>PROPAGATION_SUPPORT<br>如果外层有事务，则加入外层事务，如果外层没有事务，则直接使用非事务方式执行。完全依赖外层的事务</li><li>PROPAGATION_NOT_SUPPORT<br>该传播机制不支持事务，如果外层存在事务则挂起，执行完当前代码，则恢复外层事务，无论是否异常都不会回滚当前的代码</li><li>PROPAGATION_NEVER<br>该传播机制不支持外层事务，即如果外层有事务就抛出异常</li><li>PROPAGATION_MANDATORY<br>与NEVER相反，如果外层没有事务，则抛出异常</li><li>PROPAGATION_NESTED<br>该传播机制的特点是可以保存状态保存点，当前事务回滚到某一个点，从而避免所有的嵌套事务都回滚，即各自回滚各自的，如果子事务没有把异常吃掉，基本还是会引起全部回滚的。</li></ul><p>事务的隔离级别定义一个事务可能受其他并发务活动活动影响的程度，可以把事务的隔离级别想象为这个事务对于事物处理数据的自私程度。</p><p>在一个典型的应用程序中，多个事务同时运行，经常会为了完成他们的工作而操作同一个数据。并发虽然是必需的，但是会导致以下问题：</p><ol><li>脏读（Dirty read）<br>脏读发生在一个事务读取了被另一个事务改写但尚未提交的数据时。如果这些改变在稍后被回滚了，那么第一个事务读取的数据就会是无效的。</li><li>不可重复读（Nonrepeatable read）<br>不可重复读发生在一个事务执行相同的查询两次或两次以上，但每次查询结果都不相同时。这通常是由于另一个并发事务在两次查询之间更新了数据。</li></ol><blockquote><p>不可重复读重点在修改。</p></blockquote><ol><li>幻读（Phantom reads）<br>幻读和不可重复读相似。当一个事务（T1）读取几行记录后，另一个并发事务（T2）插入了一些记录时，幻读就发生了。在后来的查询中，第一个事务（T1）就会发现一些原来没有的额外记录。</li></ol><blockquote><p>幻读重点在新增或删除。</p></blockquote><p>在理想状态下，事务之间将完全隔离，从而可以防止这些问题发生。然而，完全隔离会影响性能，因为隔离经常涉及到锁定在数据库中的记录（甚至有时是锁表）。完全隔离要求事务相互等待来完成工作，会阻碍并发。因此，可以根据业务场景选择不同的隔离级别。</p><div class="table-container"><table><thead><tr><th>隔离级别</th><th>含义</th></tr></thead><tbody><tr><td>ISOLATION_DEFAULT</td><td>使用后端数据库默认的隔离级别</td></tr><tr><td>ISOLATION_READ_UNCOMMITTED</td><td>允许读取尚未提交的更改。可能导致脏读、幻读或不可重复读。</td></tr><tr><td>ISOLATION_READ_COMMITTED</td><td>（Oracle 默认级别）允许从已经提交的并发事务读取。可防止脏读，但幻读和不可重复读仍可能会发生。</td></tr><tr><td>ISOLATION_REPEATABLE_READ</td><td>（MYSQL默认级别）对相同字段的多次读取的结果是一致的，除非数据被当前事务本身改变。可防止脏读和不可重复读，但幻读仍可能发生。</td></tr><tr><td>ISOLATION_SERIALIZABLE</td><td>完全服从ACID的隔离级别，确保不发生脏读、不可重复读和幻影读。这在所有隔离级别中也是最慢的，因为它通常是通过完全锁定当前事务所涉及的数据表来完成的。</td></tr></tbody></table></div><h2 id="Spring-Boot-事务的使用"><a href="#Spring-Boot-事务的使用" class="headerlink" title="Spring Boot 事务的使用"></a>Spring Boot 事务的使用</h2><h3 id="Spring-Boot-事务介绍"><a href="#Spring-Boot-事务介绍" class="headerlink" title="Spring Boot 事务介绍"></a>Spring Boot 事务介绍</h3><p>使用@Transactional就可以开启Spring Boot事务注解。因为 Spring Boot中已经默认对 JPA、JDBC、Mybatis开启事务，引入它们依赖的时候，事务就默认开启。</p><h3 id="类级别事务"><a href="#类级别事务" class="headerlink" title="类级别事务"></a>类级别事务</h3><p>在类上添加@Transactional，例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AyUserServiceImpl</span> <span class="keyword">implements</span> <span class="title">AyUserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AyUserRepository ayUserRepository;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//省略下面代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Transactional注解在类上，意味着此类的所有public方法都是开启事务的。事务注解一般添加在服务实现类上。</p><h3 id="方法级别事务"><a href="#方法级别事务" class="headerlink" title="方法级别事务"></a>方法级别事务</h3><p>@Transactional 除了可以注解在类上，还可以注解到方法上面。当注解在类上时，意味着此类的所有public方法都是开启事务的。如果类级别和方法级别同时使用了@Transactional注解，就使用方法级别注解覆盖类级别注解。我们可以给AyUserServiceImpl类中的save（）方法添加事务，同时在save完成之后抛NullPointException异常，查看数据是否可以回滚，</p><p>具体代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AyUser <span class="title">save</span><span class="params">(AyUser ayUser)</span> </span>&#123;</span><br><span class="line">    AyUser saveUser = ayUserRepository.save(ayUser);</span><br><span class="line">    String error = <span class="keyword">null</span>;</span><br><span class="line">    error.split(<span class="string">"/"</span>);</span><br><span class="line">    <span class="keyword">return</span> saveUser;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>​    在测试类中添加测试方法，具体代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AyUser ayUser = <span class="keyword">new</span> AyUser();</span><br><span class="line">    ayUser.setId(<span class="string">"3"</span>);</span><br><span class="line">    ayUser.setName(<span class="string">"阿花"</span>);</span><br><span class="line">    ayUser.setPassword(<span class="string">"123"</span>);</span><br><span class="line">    ayUserService.save(ayUser);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    运行testTransaction（）单元测试用例，当代码执行完成后，由于save方法保存数据时出现空指针，数据就会回滚，因此数据库中并没有添加到数据库中。如果把AyUserServiceImpl类上的@Transactional注解和save方法上的@Transactional注解全部注释掉，再次执行testTransaction()单元测试用例，查数据库时就会发现数据库中添加到一条数据。</p><p>如下图所示:</p><p><img src="/2022/01/18/Spring-%E4%BA%8B%E5%8A%A1%E6%94%AF%E6%8C%81/image-20220118094105271.png" alt="image-20220118094105271"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Spring-Boot-事务支持&quot;&gt;&lt;a href=&quot;#Spring-Boot-事务支持&quot; class=&quot;headerlink&quot; title=&quot;Spring Boot 事务支持&quot;&gt;&lt;/a&gt;Spring Boot 事务支持&lt;/h1&gt;&lt;h2 id=&quot;Spring-事务
      
    
    </summary>
    
    
      <category term="SpringBoot" scheme="https://tropical-forest.github.io/categories/SpringBoot/"/>
    
    
      <category term="Spring Boot 事务支持" scheme="https://tropical-forest.github.io/tags/Spring-Boot-%E4%BA%8B%E5%8A%A1%E6%94%AF%E6%8C%81/"/>
    
  </entry>
  
  <entry>
    <title>使用Thymeleaf模板引擎</title>
    <link href="https://tropical-forest.github.io/2022/01/17/%E4%BD%BF%E7%94%A8Thymeleaf%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/"/>
    <id>https://tropical-forest.github.io/2022/01/17/%E4%BD%BF%E7%94%A8Thymeleaf%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/</id>
    <published>2022-01-17T15:15:04.000Z</published>
    <updated>2022-01-17T15:25:02.492Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用Thymeleaf模板引擎"><a href="#使用Thymeleaf模板引擎" class="headerlink" title="使用Thymeleaf模板引擎"></a>使用Thymeleaf模板引擎</h1><p>​    本篇博客主要介绍Thymeleaf模板引擎、Spring Boot中如何使用Thymeleaf、集成测试</p><h2 id="Thymeleaf"><a href="#Thymeleaf" class="headerlink" title="Thymeleaf"></a>Thymeleaf</h2><p>Thymeleaf是一个流行的模板引擎，该模板引擎采用Java语言开发，模板引擎是一个技术名词，是跨领域跨平台的概念，在Java语言体系下有模板引擎，在C#、PHP语言体系下也有模板引擎。除了thymeleaf之外还有Velocity、FreeMarker等模板引擎，功能类似。</p><p>Thymeleaf的主要目标在于提供一种可被浏览器正确显示的、格式良好的模板创建方式，因此也可以用作静态建模。你可以使用它创建经过验证的XML与HTML模板。使用thymeleaf创建的html模板可以在浏览器里面直接打开（展示静态数据），这有利于前后端分离。需要注意的是thymeleaf不是spring旗下的。</p><p>下面简单列举一下Thymeleaf常用的表达式、标签和函数</p><p>常用表达式：</p><ul><li>${…} 变量表达式</li><li>*{…} 选择表达式</li><li>#{…} 消息文字表达式</li><li>@{…} 链接url表达式</li><li>#maps 工具对象表达式</li></ul><p>常用标签:</p><ul><li>th:action 定义后台控制器路径</li><li>th:each 循环语句</li><li>th:field 表单字段绑定</li><li>th:href 定义超链接</li><li>th:id div标签中的ID声明，类似HTML标签中的ID属性</li><li>th:if 条件判断语句</li><li>th:include 布局标签，替换内容到引入文件</li><li>th:fragment 布局标签，定义一个代码片段，方便其他地方引用</li><li>th:object 替换对象</li><li>th:src 图片类地址引入</li><li>th:text 显示文本</li><li>th:value 属性赋值</li></ul><p>常用函数：</p><ul><li>#dates 日期函数</li><li>#lists 列表函数</li><li>#arrays 数组函数</li><li>#strings 字符串函数</li><li>#numbers 数字函数</li><li>#calendars 日历函数</li><li>#objects 对象函数</li><li>#bools 逻辑函数</li></ul><h2 id="使用-Thymeleaf模板引擎"><a href="#使用-Thymeleaf模板引擎" class="headerlink" title="使用 Thymeleaf模板引擎"></a>使用 Thymeleaf模板引擎</h2><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在application.yaml进行配置，配置代码如下:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### thymeleaf配置</span></span><br><span class="line"><span class="attr">thymeleaf:</span></span><br><span class="line">  <span class="attr">mode:</span> <span class="string">HTML5</span></span><br><span class="line">  <span class="attr">encoding:</span> <span class="string">utf-8</span></span><br><span class="line">  <span class="comment">### 内容类别，可不用配置</span></span><br><span class="line">  <span class="attr">servlet:</span></span><br><span class="line">    <span class="attr">content-type:</span> <span class="string">text/html</span></span><br><span class="line">  <span class="comment">### 开发配置false,避免修改模板还要重启服务器</span></span><br><span class="line">  <span class="attr">cache:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment">### 配置模板路径，默认是templates，可以不用配置</span></span><br><span class="line">  <span class="attr">prefix:</span> <span class="string">classpath:/templates/</span></span><br></pre></td></tr></table></figure><h3 id="控制层开发"><a href="#控制层开发" class="headerlink" title="控制层开发"></a>控制层开发</h3><p>​    在项目目录/src/main/java/com.lpy.controller下开发控制层AyUserController.java，同时把AyUserService服务注入控制层类中。具体代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/ayUser"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AyUserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> AyUserService ayUserService;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@RequestMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(Model model)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//查询数据库所有用户</span></span><br><span class="line">       List&lt;AyUser&gt; ayUserList = ayUserService.findAll();</span><br><span class="line">       model.addAttribute(<span class="string">"users"</span>,ayUserList);</span><br><span class="line">       <span class="keyword">return</span> <span class="string">"ayUser"</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Thymeleaf模板页面开发"><a href="#Thymeleaf模板页面开发" class="headerlink" title="Thymeleaf模板页面开发"></a>Thymeleaf模板页面开发</h3><p>​    控制层类AyUserController.java开发完成之后，我们继续在/src/main/resources/templates目录下开发ayUser.html，具体代码如下:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>用户名<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>密码<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span> <span class="attr">th:each</span>=<span class="string">"user:$&#123;users&#125;"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;user.name&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;user.password&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h2><p>​    现在运行项目，然后在浏览器中访问<a href="http://localhost:8080/ayUser/test" target="_blank" rel="noopener">http://localhost:8080/ayUser/test</a></p><p><img src="/2022/01/17/%E4%BD%BF%E7%94%A8Thymeleaf%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/image-20220117230846238.png" alt="image-20220117230846238"></p><p>出现类似上图结果，则表示thymeleaf使用成功。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;使用Thymeleaf模板引擎&quot;&gt;&lt;a href=&quot;#使用Thymeleaf模板引擎&quot; class=&quot;headerlink&quot; title=&quot;使用Thymeleaf模板引擎&quot;&gt;&lt;/a&gt;使用Thymeleaf模板引擎&lt;/h1&gt;&lt;p&gt;​    本篇博客主要介绍Thyme
      
    
    </summary>
    
    
      <category term="SpringBoot" scheme="https://tropical-forest.github.io/categories/SpringBoot/"/>
    
    
      <category term="thymeleaf" scheme="https://tropical-forest.github.io/tags/thymeleaf/"/>
    
  </entry>
  
  <entry>
    <title>集成 Spring Data JPA</title>
    <link href="https://tropical-forest.github.io/2022/01/17/%E9%9B%86%E6%88%90-Spring-Data-JPA/"/>
    <id>https://tropical-forest.github.io/2022/01/17/%E9%9B%86%E6%88%90-Spring-Data-JPA/</id>
    <published>2022-01-17T10:12:58.000Z</published>
    <updated>2022-01-17T11:28:31.728Z</updated>
    
    <content type="html"><![CDATA[<h1 id="集成-Spring-Data-JPA"><a href="#集成-Spring-Data-JPA" class="headerlink" title="集成 Spring Data JPA"></a>集成 Spring Data JPA</h1><h2 id="Spring-Data-JPA介绍"><a href="#Spring-Data-JPA介绍" class="headerlink" title="Spring Data JPA介绍"></a>Spring Data JPA介绍</h2><p>本节主要介绍Spring Data JPA是什么、Spring Data JPA 核心接口Repository、核心接口间的继承关系图</p><h3 id="Spring-Data-JPA介绍-1"><a href="#Spring-Data-JPA介绍-1" class="headerlink" title="Spring Data JPA介绍"></a>Spring Data JPA介绍</h3><ul><li>JPA是Sun官方提出的Java持久化规范</li><li>JPA的主要实现有Hibernate、EclipseLink、OpenJPA等</li><li>Spring Data JPA是Spring Data的一个子项目，通过提供基于JPA的Repository极大地减少了JPA作为数据访问方案的代码量。</li><li>通过Spring Data JPA框架，开发者可以省略持久层业务逻辑的工作，唯一要做的就是声明持久层的接口，其他都交给Spring Data JPA来完成。</li></ul><h3 id="核心接口-Repository"><a href="#核心接口-Repository" class="headerlink" title="核心接口 Repository"></a>核心接口 Repository</h3><p>​    Spring Data JPA是最顶层的接口是Repository，该接口是所有Repository类的父类。</p><p>​    Repository接口的子类有CrudRepository、PagingAndSortingRepository、JpaRepository等。其中，CrudRepository类提供了基本的增删改查等接口，PagingAndSortingRepository类提供了基本的分页和排序接口，而JpaRepository是CurdRepository和PagingAndSortingRepository的子类，继承了它们的所有接口。在实际的项目开发中，我们都是通过实现JpaRepository或者其子类进行基本的数据库操作。</p><h3 id="接口继承关系图"><a href="#接口继承关系图" class="headerlink" title="接口继承关系图"></a>接口继承关系图</h3><p><img src="/2022/01/17/%E9%9B%86%E6%88%90-Spring-Data-JPA/image-20190117111412608.png" alt="image-20190117111412608"></p><h2 id="集成-Spring-Data-JPA-1"><a href="#集成-Spring-Data-JPA-1" class="headerlink" title="集成 Spring Data JPA"></a>集成 Spring Data JPA</h2><p>本节通过Spring Data JPA 实现基本的增删改查功能</p><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>mysql-connector-java: MySQL连接Java的驱动程序。</li><li>spring-boot-starter-jdbc：支持通过JDBC连接数据库</li></ul><h3 id="添加数据库配置"><a href="#添加数据库配置" class="headerlink" title="添加数据库配置"></a>添加数据库配置</h3><p>在application.yaml添加如下的配置信息</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### mysql连接信息</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://127.0.0.1:3306/test</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br></pre></td></tr></table></figure><h3 id="设计表和实体"><a href="#设计表和实体" class="headerlink" title="设计表和实体"></a>设计表和实体</h3><p>在test数据库里面添加ay_user表，表结构如下图所示:</p><p><img src="/2022/01/17/%E9%9B%86%E6%88%90-Spring-Data-JPA/image-20220117174721585.png" alt="image-20220117174721585"></p><p>整个项目结构如下图所示:</p><p><img src="/2022/01/17/%E9%9B%86%E6%88%90-Spring-Data-JPA/image-20220117174946310.png" alt="image-20220117174721585"></p><p>实体类AyUser的代码如下图所示:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AyUser</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Data是使用来自于lombok插件的方法，如果没有则需要安装</p><h3 id="继承-JpaRepository"><a href="#继承-JpaRepository" class="headerlink" title="继承 JpaRepository"></a>继承 JpaRepository</h3><p>AyUserRepositor接口的代码如下图所示:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AyUserRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">AyUser</span>,<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">List&lt;AyUser&gt; <span class="title">findByName</span><span class="params">(String name)</span></span>;</span><br><span class="line">    <span class="function">List&lt;AyUser&gt; <span class="title">findByNameLike</span><span class="params">(String name)</span></span>;</span><br><span class="line">    <span class="function">List&lt;AyUser&gt; <span class="title">findByIdIn</span><span class="params">(Collection&lt;String&gt; ids)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="服务层类实现"><a href="#服务层类实现" class="headerlink" title="服务层类实现"></a>服务层类实现</h3><p>AyUserService接口类代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AyUserService</span> </span>&#123;</span><br><span class="line">    <span class="function">AyUser <span class="title">findById</span><span class="params">(String id)</span></span>;</span><br><span class="line">    <span class="function">List&lt;AyUser&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">AyUser <span class="title">save</span><span class="params">(AyUser ayUser)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(String id)</span></span>;</span><br><span class="line">    <span class="comment">//分页</span></span><br><span class="line">   <span class="function">Page&lt;AyUser&gt; <span class="title">findAll</span><span class="params">(Pageable pageable)</span></span>;</span><br><span class="line">   <span class="function">List&lt;AyUser&gt; <span class="title">findByName</span><span class="params">(String name)</span></span>;</span><br><span class="line">   <span class="function">List&lt;AyUser&gt; <span class="title">findByNameLike</span><span class="params">(String name)</span></span>;</span><br><span class="line">   <span class="function">List&lt;AyUser&gt; <span class="title">findByIdIn</span><span class="params">(Collection&lt;String&gt; ids)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AyUserServiceImpl类的代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AyUserServiceImpl</span> <span class="keyword">implements</span> <span class="title">AyUserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AyUserRepository ayUserRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AyUser <span class="title">findById</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ayUserRepository.findById(id).orElse(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;AyUser&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ayUserRepository.findAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AyUser <span class="title">save</span><span class="params">(AyUser ayUser)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ayUserRepository.save(ayUser);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        ayUserRepository.deleteById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Page&lt;AyUser&gt; <span class="title">findAll</span><span class="params">(Pageable pageable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ayUserRepository.findAll(pageable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;AyUser&gt; <span class="title">findByName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ayUserRepository.findByName(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;AyUser&gt; <span class="title">findByNameLike</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ayUserRepository.findByNameLike(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;AyUser&gt; <span class="title">findByIdIn</span><span class="params">(Collection&lt;String&gt; ids)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ayUserRepository.findByIdIn(ids);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h2><h3 id="测试用例开发"><a href="#测试用例开发" class="headerlink" title="测试用例开发"></a>测试用例开发</h3><p>在测试类中添加如下代码，如下所示:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRepository</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//查询所有数据</span></span><br><span class="line">        List&lt;AyUser&gt; userList1 = ayUserService.findAll();</span><br><span class="line">        System.out.println(<span class="string">"findAll() :"</span> + userList1.size());</span><br><span class="line">        <span class="comment">//通过name查询数据</span></span><br><span class="line">        List&lt;AyUser&gt; userList2 = ayUserService.findByName(<span class="string">"阿毅"</span>);</span><br><span class="line">        System.out.println(<span class="string">"findByName() :"</span>+userList2.size());</span><br><span class="line">        Assert.isTrue(userList2.get(<span class="number">0</span>).getName().equals(<span class="string">"阿毅"</span>),<span class="string">"data error!"</span>);</span><br><span class="line">        <span class="comment">//通过name模糊查询数据</span></span><br><span class="line">        List&lt;AyUser&gt; userList3 = ayUserService.findByNameLike(<span class="string">"%毅%"</span>);</span><br><span class="line">        System.out.println(<span class="string">"findByNameLike() :"</span> + userList3.size());</span><br><span class="line">        Assert.isTrue(userList3.get(<span class="number">0</span>).getName().equals(<span class="string">"阿毅"</span>),<span class="string">"data error!"</span>);</span><br><span class="line">        <span class="comment">//通过id列表查询数据</span></span><br><span class="line">        List&lt;String&gt; ids = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        ids.add(<span class="string">"1"</span>);</span><br><span class="line">        ids.add(<span class="string">"2"</span>);</span><br><span class="line">        List&lt;AyUser&gt; userList4 = ayUserService.findByIdIn(ids);</span><br><span class="line">        System.out.println(<span class="string">"findByIdIn() :"</span> + userList4.size());</span><br><span class="line">        <span class="comment">//分页查询数据</span></span><br><span class="line">        PageRequest pageRequest = PageRequest.of(<span class="number">0</span>,<span class="number">10</span>);</span><br><span class="line">        Page&lt;AyUser&gt; userList5  = ayUserService.findAll(pageRequest);</span><br><span class="line">        System.out.println(<span class="string">"page findAll():"</span>+userList5.getTotalPages()+<span class="string">"/"</span>+userList5.getSize());</span><br><span class="line">        <span class="comment">//新增数据</span></span><br><span class="line">        AyUser ayUser = <span class="keyword">new</span> AyUser();</span><br><span class="line">        ayUser.setId(<span class="string">"3"</span>);</span><br><span class="line">        ayUser.setName(<span class="string">"test"</span>);</span><br><span class="line">        ayUser.setPassword(<span class="string">"123"</span>);</span><br><span class="line">        ayUserService.save(ayUser);</span><br><span class="line">        <span class="comment">//删除数据</span></span><br><span class="line">        ayUserService.delete(<span class="string">"3"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>运行上面的测试用例的效果图如下所示:</p><p><img src="/2022/01/17/%E9%9B%86%E6%88%90-Spring-Data-JPA/image-20220117180816936.png" alt="image-20220117180816936"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;集成-Spring-Data-JPA&quot;&gt;&lt;a href=&quot;#集成-Spring-Data-JPA&quot; class=&quot;headerlink&quot; title=&quot;集成 Spring Data JPA&quot;&gt;&lt;/a&gt;集成 Spring Data JPA&lt;/h1&gt;&lt;h2 id=&quot;S
      
    
    </summary>
    
    
      <category term="SpringBoot" scheme="https://tropical-forest.github.io/categories/SpringBoot/"/>
    
    
      <category term="Spring Data JPA" scheme="https://tropical-forest.github.io/tags/Spring-Data-JPA/"/>
    
  </entry>
  
  <entry>
    <title>老毛子固件搞定锐捷认证</title>
    <link href="https://tropical-forest.github.io/2021/05/02/%E7%94%A8%E8%B7%AF%E7%94%B1%E5%99%A8%E7%BB%8F%E8%BF%87%E6%A0%A1%E5%9B%AD%E7%BD%91%E7%9A%84%E9%94%90%E6%8D%B7%E8%AE%A4%E8%AF%81%EF%BC%8C%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%B4%A6%E5%8F%B7%E5%85%A8%E5%AE%BF%E8%88%8D%E4%B8%8A%E7%BD%91/"/>
    <id>https://tropical-forest.github.io/2021/05/02/%E7%94%A8%E8%B7%AF%E7%94%B1%E5%99%A8%E7%BB%8F%E8%BF%87%E6%A0%A1%E5%9B%AD%E7%BD%91%E7%9A%84%E9%94%90%E6%8D%B7%E8%AE%A4%E8%AF%81%EF%BC%8C%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%B4%A6%E5%8F%B7%E5%85%A8%E5%AE%BF%E8%88%8D%E4%B8%8A%E7%BD%91/</id>
    <published>2021-05-02T13:16:33.000Z</published>
    <updated>2021-05-03T03:42:37.888Z</updated>
    
    <content type="html"><![CDATA[<p>前言：<br>    如果你有一个校园网账号，想要实现全宿舍上网却因为锐捷认证问题所烦恼的话，那么这篇博客很适合你阅读。这篇博客是写通过一个刷有老毛子固件的路由器实现锐捷认证，实现全宿舍上网的方法。</p><h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p><img src="/2021/05/02/%E7%94%A8%E8%B7%AF%E7%94%B1%E5%99%A8%E7%BB%8F%E8%BF%87%E6%A0%A1%E5%9B%AD%E7%BD%91%E7%9A%84%E9%94%90%E6%8D%B7%E8%AE%A4%E8%AF%81%EF%BC%8C%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%B4%A6%E5%8F%B7%E5%85%A8%E5%AE%BF%E8%88%8D%E4%B8%8A%E7%BD%91/show.JPG" alt="锐捷认证成功后的效果图">这是刷有老毛子固件的路由器后台，经过锐捷认证成功后你就会发现地球图标上会出现绿色的√，若没有成功，则是红色的x。</p><h2 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h2><p>在操作开始之前，先准备好下面条件。不会刷路由器的朋友可以上某宝或某多等平台去淘装好固件的路由器，估计四十或五十就有了。WinSCP直接百度安装，抓包工具需要从下面网盘链接中下载下来，下面操作步骤中将会用到。</p><ul><li>带有老毛子固件的路由器</li><li>装好WinSCP软件</li><li><a href="https://pan.baidu.com/s/1dsBXKgT2cQ0FYQDk9OxGfA" target="_blank" rel="noopener">抓包工具</a>(提取码：sedx )</li></ul><h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><h3 id="获取正常认证成功后的mac地址"><a href="#获取正常认证成功后的mac地址" class="headerlink" title="获取正常认证成功后的mac地址"></a>获取正常认证成功后的mac地址</h3><p>首先用你的电脑网线连接, 然后正常启动官方的认证程序, 然后连接之后查看自己的网卡mac地址,然后把它记下来，后面会用到这个max地址。因为接下来的dhcp服务器进行ip分配的时候, 是通过你后台注册的mac地址进行分配的.这个步骤很重要!!!<br><img src="/2021/05/02/%E7%94%A8%E8%B7%AF%E7%94%B1%E5%99%A8%E7%BB%8F%E8%BF%87%E6%A0%A1%E5%9B%AD%E7%BD%91%E7%9A%84%E9%94%90%E6%8D%B7%E8%AE%A4%E8%AF%81%EF%BC%8C%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%B4%A6%E5%8F%B7%E5%85%A8%E5%AE%BF%E8%88%8D%E4%B8%8A%E7%BD%91/max.JPG" alt="max地址"><br>这里需要除了记住mac地址外，还有把锐捷认证成功后的ip地址、网关地址、DNS地址，建议把截图，因为后面路由器锐捷认证填写信息会用到它。如下所示<br><img src="/2021/05/02/%E7%94%A8%E8%B7%AF%E7%94%B1%E5%99%A8%E7%BB%8F%E8%BF%87%E6%A0%A1%E5%9B%AD%E7%BD%91%E7%9A%84%E9%94%90%E6%8D%B7%E8%AE%A4%E8%AF%81%EF%BC%8C%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%B4%A6%E5%8F%B7%E5%85%A8%E5%AE%BF%E8%88%8D%E4%B8%8A%E7%BD%91/information.JPG" alt="锐捷认证信息"></p><h3 id="抓取数据包"><a href="#抓取数据包" class="headerlink" title="抓取数据包"></a>抓取数据包</h3><p>经过前面条件那里，你应该安装好了抓包工具，抓包工具解压后的效果图如下所示。<br><img src="/2021/05/02/%E7%94%A8%E8%B7%AF%E7%94%B1%E5%99%A8%E7%BB%8F%E8%BF%87%E6%A0%A1%E5%9B%AD%E7%BD%91%E7%9A%84%E9%94%90%E6%8D%B7%E8%AE%A4%E8%AF%81%EF%BC%8C%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%B4%A6%E5%8F%B7%E5%85%A8%E5%AE%BF%E8%88%8D%E4%B8%8A%E7%BD%91/bao.JPG" alt="抓包工具"><br>再把里面“锐捷测试软件和教程”压缩包解压，其效果图如下。<br><img src="/2021/05/02/%E7%94%A8%E8%B7%AF%E7%94%B1%E5%99%A8%E7%BB%8F%E8%BF%87%E6%A0%A1%E5%9B%AD%E7%BD%91%E7%9A%84%E9%94%90%E6%8D%B7%E8%AE%A4%E8%AF%81%EF%BC%8C%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%B4%A6%E5%8F%B7%E5%85%A8%E5%AE%BF%E8%88%8D%E4%B8%8A%E7%BD%91/bao2.JPG" alt="抓包工具"><br>抓包工具里面有关于抓包的教程，请自行抓包。抓包成功后保存文件名随便取，这里方便测试，就取11.mdf为文件名。</p><h3 id="进入后台将SSH选项设置打开"><a href="#进入后台将SSH选项设置打开" class="headerlink" title="进入后台将SSH选项设置打开"></a>进入后台将SSH选项设置打开</h3><p>打开你的浏览器，输入网址192.168.123.1<br><img src="/2021/05/02/%E7%94%A8%E8%B7%AF%E7%94%B1%E5%99%A8%E7%BB%8F%E8%BF%87%E6%A0%A1%E5%9B%AD%E7%BD%91%E7%9A%84%E9%94%90%E6%8D%B7%E8%AE%A4%E8%AF%81%EF%BC%8C%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%B4%A6%E5%8F%B7%E5%85%A8%E5%AE%BF%E8%88%8D%E4%B8%8A%E7%BD%91/后台.JPG" alt="后台"><br>建议先把路由器恢复出厂设置，避免受到其他设置的影响，从而提高成功率。然后再接着下面操作<br>1.再进入左侧的系统管理→2右侧服务→3.然后启动SSH服务<br>这样就可以进行下一步，使用WINSCP导入数据包<br><img src="/2021/05/02/%E7%94%A8%E8%B7%AF%E7%94%B1%E5%99%A8%E7%BB%8F%E8%BF%87%E6%A0%A1%E5%9B%AD%E7%BD%91%E7%9A%84%E9%94%90%E6%8D%B7%E8%AE%A4%E8%AF%81%EF%BC%8C%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%B4%A6%E5%8F%B7%E5%85%A8%E5%AE%BF%E8%88%8D%E4%B8%8A%E7%BD%91/ssh.JPG" alt="ssh"></p><h3 id="用winscp连接上路由器-把11-mdf传到老毛子的-etc-storage文件夹下-必须是这个文件夹，因为老毛子其他文件夹重启后就会丢失"><a href="#用winscp连接上路由器-把11-mdf传到老毛子的-etc-storage文件夹下-必须是这个文件夹，因为老毛子其他文件夹重启后就会丢失" class="headerlink" title="用winscp连接上路由器, 把11.mdf传到老毛子的/etc/storage文件夹下(必须是这个文件夹，因为老毛子其他文件夹重启后就会丢失)"></a>用winscp连接上路由器, 把11.mdf传到老毛子的/etc/storage文件夹下(必须是这个文件夹，因为老毛子其他文件夹重启后就会丢失)</h3><p><img src="/2021/05/02/%E7%94%A8%E8%B7%AF%E7%94%B1%E5%99%A8%E7%BB%8F%E8%BF%87%E6%A0%A1%E5%9B%AD%E7%BD%91%E7%9A%84%E9%94%90%E6%8D%B7%E8%AE%A4%E8%AF%81%EF%BC%8C%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%B4%A6%E5%8F%B7%E5%85%A8%E5%AE%BF%E8%88%8D%E4%B8%8A%E7%BD%91/winscp.JPG" alt="11.mpf在winscp里面的位置"></p><h3 id="在后台输入你的账号信息"><a href="#在后台输入你的账号信息" class="headerlink" title="在后台输入你的账号信息"></a>在后台输入你的账号信息</h3><p>1.打开后台—-》2.打开配置拓展环境—-》3.打开锐捷认证功能—》4.添加基本信息<br><img src="/2021/05/02/%E7%94%A8%E8%B7%AF%E7%94%B1%E5%99%A8%E7%BB%8F%E8%BF%87%E6%A0%A1%E5%9B%AD%E7%BD%91%E7%9A%84%E9%94%90%E6%8D%B7%E8%AE%A4%E8%AF%81%EF%BC%8C%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%B4%A6%E5%8F%B7%E5%85%A8%E5%AE%BF%E8%88%8D%E4%B8%8A%E7%BD%91/information1.JPG" alt="填写锐捷认证信息1"><br><img src="/2021/05/02/%E7%94%A8%E8%B7%AF%E7%94%B1%E5%99%A8%E7%BB%8F%E8%BF%87%E6%A0%A1%E5%9B%AD%E7%BD%91%E7%9A%84%E9%94%90%E6%8D%B7%E8%AE%A4%E8%AF%81%EF%BC%8C%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%B4%A6%E5%8F%B7%E5%85%A8%E5%AE%BF%E8%88%8D%E4%B8%8A%E7%BD%91/information2.JPG" alt="填写锐捷认证信息2"><br><img src="/2021/05/02/%E7%94%A8%E8%B7%AF%E7%94%B1%E5%99%A8%E7%BB%8F%E8%BF%87%E6%A0%A1%E5%9B%AD%E7%BD%91%E7%9A%84%E9%94%90%E6%8D%B7%E8%AE%A4%E8%AF%81%EF%BC%8C%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%B4%A6%E5%8F%B7%E5%85%A8%E5%AE%BF%E8%88%8D%E4%B8%8A%E7%BD%91/information3.JPG" alt="填写锐捷认证信息3"><br><img src="/2021/05/02/%E7%94%A8%E8%B7%AF%E7%94%B1%E5%99%A8%E7%BB%8F%E8%BF%87%E6%A0%A1%E5%9B%AD%E7%BD%91%E7%9A%84%E9%94%90%E6%8D%B7%E8%AE%A4%E8%AF%81%EF%BC%8C%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%B4%A6%E5%8F%B7%E5%85%A8%E5%AE%BF%E8%88%8D%E4%B8%8A%E7%BD%91/information4.JPG" alt="填写锐捷认证信息4"><br>最后按“应该本页面设置”按钮，使设置信息生效。<br>接下来填写mac地址、宽度账号和密码，和设置为动态获得的方式来上网。如下图所示<br><img src="/2021/05/02/%E7%94%A8%E8%B7%AF%E7%94%B1%E5%99%A8%E7%BB%8F%E8%BF%87%E6%A0%A1%E5%9B%AD%E7%BD%91%E7%9A%84%E9%94%90%E6%8D%B7%E8%AE%A4%E8%AF%81%EF%BC%8C%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%B4%A6%E5%8F%B7%E5%85%A8%E5%AE%BF%E8%88%8D%E4%B8%8A%E7%BD%91/information5.JPG" alt="填写锐捷认证信息5"><br>最后按“应该本页面设置”按钮，使设置信息生效。到这里，整个操作都做完了，这时候你就会发现地球图标上会出现绿色的√，可以自由冲浪了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>终于坚持写完了，与锐捷认证的斗争终于告一段落。虽然是可以搞定锐捷认证，但都是借用别人的工具来使用，还是不太懂里面的原理，看来《计算机网络》的知识还不过关，还需要继续学习计算机网络知识。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>+<a href="https://blog.csdn.net/weixin_40500627/article/details/108395293" target="_blank" rel="noopener">老毛子固件搞定锐捷认证</a><br>+<a href="https://blog.csdn.net/Hj127666/article/details/114670652" target="_blank" rel="noopener">锐捷6.41，静态ip，学生破解过程分享</a></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>如果大家有什么指教的话，可以在下面留言。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前言：&lt;br&gt;    如果你有一个校园网账号，想要实现全宿舍上网却因为锐捷认证问题所烦恼的话，那么这篇博客很适合你阅读。这篇博客是写通过一个刷有老毛子固件的路由器实现锐捷认证，实现全宿舍上网的方法。&lt;/p&gt;
&lt;h2 id=&quot;效果展示&quot;&gt;&lt;a href=&quot;#效果展示&quot; cla
      
    
    </summary>
    
    
      <category term="其他" scheme="https://tropical-forest.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="锐捷认证" scheme="https://tropical-forest.github.io/tags/%E9%94%90%E6%8D%B7%E8%AE%A4%E8%AF%81/"/>
    
      <category term="老毛子固件" scheme="https://tropical-forest.github.io/tags/%E8%80%81%E6%AF%9B%E5%AD%90%E5%9B%BA%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>数字三角形问题</title>
    <link href="https://tropical-forest.github.io/2020/11/19/%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2%E9%97%AE%E9%A2%98/"/>
    <id>https://tropical-forest.github.io/2020/11/19/%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2%E9%97%AE%E9%A2%98/</id>
    <published>2020-11-19T11:11:58.000Z</published>
    <updated>2020-11-19T11:24:36.587Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">问题描述：</span><br><span class="line">给定一个由n行数字组成的数字三角形如下图所示。试设计一个算法，计算出从三角形</span><br><span class="line">的顶至底的一条路径，使该路径经过的数字总和最大。</span><br><span class="line">    7</span><br><span class="line">   3 8</span><br><span class="line">  8 1 0</span><br><span class="line"> 2 7 4 4</span><br><span class="line">4 5 2 6 5</span><br><span class="line">编程任务：</span><br><span class="line">对于给定的由n行数字组成的数字三角形，编程计算从三角形的顶至底的路径经过的数字和的最大值。</span><br><span class="line">数据输入：</span><br><span class="line">由文件input.txt 提供输入数据。文件的第1 行是数字三角形的行数n，1£n£100。接下来n行是数字三角形各行中的数字。所有数字在0..99之间。输入数据由文件名为 input.txt 的文本文件提供。</span><br><span class="line">结果输出:</span><br><span class="line">程序运行结束时，将计算结果输出到文件output.txt 中。文件的第1 行中的数是计算</span><br><span class="line">出的最大值。</span><br><span class="line">输入文件示例   输出文件示例</span><br><span class="line">7               30</span><br><span class="line">3 8</span><br><span class="line">8 1 0</span><br><span class="line">2 7 4 4</span><br><span class="line">4 5 2 6 5</span><br></pre></td></tr></table></figure><h2 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h2><p>数字三角形中每个数字我们可以用一个二维坐标来表示，例如第1行第1列表示为triangle(1,1)。分析题目可知，经过某个坐标的最大数字和跟该坐标的上面的数字最大数字和有关，所以关于这个问题我们可以用动态规划来解决。先把一个复杂的问题化为n个有关联的子问题。在这里，我们从顶点到底部，依次就算每个坐标的最大数字和。因为后面的坐标会用到前面的坐标数字和，所以我们每计算一个坐标数字和时，都需要把该数字和保存的一个表上，都时候需要用到前面的坐标数字和时，就不需要再计算，直接引用即可，算法效率就会大大提高。设a(i,j)表示坐标triangle(i,j)的数字，d(triangle(i,j))表示经过坐标triangle(i,j)的最大数字和，在这个问题中，我们可以分析一个坐标triangle(i,j) 的位置置换方程为d(triangle(i,j))= max{d(triangle(i-1,j-1),d(triangle(i-1,j))}+a(i,j);</p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求从顶点到底层的最长路径，也即是数字和最大</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLongestPath</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; triangle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">line</span> = triangle.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> longestPath=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; table;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">line</span>&lt;<span class="number">1</span>) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="built_in">line</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">1</span>) &#123; temp = triangle[i<span class="number">-1</span>][j<span class="number">-1</span>]; &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j==<span class="number">1</span>) &#123; temp = table[i<span class="number">-1</span><span class="number">-1</span>][j<span class="number">-1</span>] + triangle[i<span class="number">-1</span>][j<span class="number">-1</span>]; &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j==i) &#123; temp = table[i<span class="number">-1</span><span class="number">-1</span>][j<span class="number">-1</span><span class="number">-1</span>] + triangle[i<span class="number">-1</span>][j<span class="number">-1</span>];&#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; temp = <span class="built_in">max</span>(table[i<span class="number">-1</span><span class="number">-1</span>][j<span class="number">-1</span><span class="number">-1</span>],table[i<span class="number">-1</span><span class="number">-1</span>][j<span class="number">-1</span>]) + triangle[i<span class="number">-1</span>][j<span class="number">-1</span>]; &#125;</span><br><span class="line">            data.push_back(temp);</span><br><span class="line">            <span class="keyword">if</span>(temp &gt;longestPath) &#123; longestPath = temp; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        table.push_back(data);</span><br><span class="line">        data.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">return</span> longestPath;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="comment">//标准输入输出重定向到文件中</span></span><br><span class="line">    freopen(<span class="string">"data.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"data.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; triangle;  <span class="comment">//用来保存数字三角形数据的二维数组</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">line</span>;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; <span class="built_in">line</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">line</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; temp;</span><br><span class="line">            data.push_back(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        triangle.push_back(data);</span><br><span class="line">        data.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; getLongestPath(triangle);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h2><p>由算法很容易知道时间复杂度为n^2</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>动态规划就是把一个较为复杂的问题分为多个子问题，而且这些子问题是有关联的，一个子问题的计算结果可能会用到其他子问题的计算结果。所以为避免多次运算，我们可以把已经计算过的子问题的结果保存到一个表中，当要用到已经计算的子问题的结果时，直接引用表中的数据即可，这样子效率就得到大大的提高。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pr
      
    
    </summary>
    
    
      <category term="算法设计与分析" scheme="https://tropical-forest.github.io/categories/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"/>
    
    
  </entry>
  
  <entry>
    <title>弃用鼠标，高效工作</title>
    <link href="https://tropical-forest.github.io/2020/10/17/%E5%BC%83%E7%94%A8%E9%BC%A0%E6%A0%87%EF%BC%8C%E9%AB%98%E6%95%88%E5%B7%A5%E4%BD%9C/"/>
    <id>https://tropical-forest.github.io/2020/10/17/%E5%BC%83%E7%94%A8%E9%BC%A0%E6%A0%87%EF%BC%8C%E9%AB%98%E6%95%88%E5%B7%A5%E4%BD%9C/</id>
    <published>2020-10-17T01:37:17.000Z</published>
    <updated>2020-10-17T02:24:45.896Z</updated>
    
    <content type="html"><![CDATA[<p>作为一名程序员，尽量使用键盘和少用鼠标是提高工作效率的一种有用的方式，因为程序员使用电脑很多都是敲代码，双手始终放在键盘上，可以提高代码编写的速度，如果常用鼠标，就会有了鼠标和键盘来回切换的时间，这样子会降低工作效率，为了高效工作，尽量不用鼠标和多用键盘。</p><p>为了少用鼠标的话，就需要掌握一些常用的快捷键，掌握常用的快捷键就可以放弃鼠标了<br>以下快捷键适用于win10,其他系统可能不适用。<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">(一)Win键</span><br><span class="line">win + e；打开资源管理器</span><br><span class="line">win + d；显示桌面，再按一次恢复窗口</span><br><span class="line">win + r<span class="comment">; 运行对话框，这个运行如果用的话，基本上就可以告别鼠标:</span></span><br><span class="line"><span class="number">1</span>. 在运行对话框内输入cmd,进入命令行模式</span><br><span class="line"><span class="number">2</span>. 在运行对话框中输入control,进入控制面板</span><br><span class="line"><span class="number">3</span>. 在运行对话框中输入appwiz.cpl，进入程序与功能</span><br><span class="line"><span class="number">4</span>. 在运行对话框中输入msconfig，进入系统配置</span><br><span class="line"><span class="number">5</span>. 在运行对话框中输入Chrome，打开谷歌浏览器，前提是你安装了chrome.同理这个可以用来快捷的打开一些应用程序。如果是经常使用的应用程序可以将它固定到任务栏或者开始屏幕。或者设置快捷键来访问</span><br><span class="line"><span class="number">6</span>. 在对话框内输入<span class="keyword">shutdown </span>-s -t <span class="number">0</span><span class="comment">;立刻关机，后面的0代表0秒后关机。可以修改为600，就是十分钟后关机</span></span><br><span class="line">win + x<span class="comment">;这个可以打开很多相关设置</span></span><br><span class="line"><span class="number">7</span>.在运行对话框中输入<span class="keyword">shutdown </span>-a 取消定时关机</span><br><span class="line">win + space；切换输入法；<span class="keyword">shift可以快速切换中英文</span></span><br><span class="line"><span class="keyword">win </span>+ l<span class="comment">; 锁定屏幕</span></span><br><span class="line">win + s<span class="comment">;搜索（推荐使用，这个可以完成很多软件的打开)</span></span><br><span class="line">win + tab<span class="comment">; 切换桌面</span></span><br><span class="line">alt + tab<span class="comment">; 切换同桌面的不同程序</span></span><br><span class="line">win + ctrl + d<span class="comment">;创建新桌面</span></span><br><span class="line">win + 向上方向键；窗口最大化</span><br><span class="line">win + 向左 + 向右<span class="comment">;左上角四份之一窗口</span></span><br><span class="line">（二）ctrl键和Alt键，Ctrl和Alt键大多数会配合应用程序使用</span><br><span class="line">ctrl + <span class="keyword">shift </span>+ esc<span class="comment">; 呼出任务管理器</span></span><br><span class="line">chrome适用的快捷键</span><br><span class="line">ctrl + w<span class="comment">; 关闭标签</span></span><br><span class="line">ctrl + t<span class="comment">;新建标签</span></span><br><span class="line">ctrl + <span class="keyword">shift </span>+ t<span class="comment">;恢复刚关闭的标签</span></span><br><span class="line">ctrl + h<span class="comment">;历史记录</span></span><br><span class="line">ctrl + <span class="keyword">j;下载列表</span></span><br><span class="line"><span class="keyword">ctrl </span>+ f<span class="comment">;在页面内查找</span></span><br><span class="line">ctrl + n<span class="comment">;新窗口</span></span><br><span class="line">ctrl + tab<span class="comment">;切换到下一个标签</span></span><br><span class="line">ctrl + <span class="keyword">shift </span>+ tab<span class="comment">;切换到上一个标签</span></span><br><span class="line">ctrl + r<span class="comment">;重新加载当前页</span></span><br><span class="line">ctrl + d<span class="comment">;加入书签</span></span><br><span class="line">alt + d<span class="comment">;输入定位到地址栏</span></span><br><span class="line">alt + spance<span class="comment">;呼出窗口控制的菜单</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作为一名程序员，尽量使用键盘和少用鼠标是提高工作效率的一种有用的方式，因为程序员使用电脑很多都是敲代码，双手始终放在键盘上，可以提高代码编写的速度，如果常用鼠标，就会有了鼠标和键盘来回切换的时间，这样子会降低工作效率，为了高效工作，尽量不用鼠标和多用键盘。&lt;/p&gt;
&lt;p&gt;为
      
    
    </summary>
    
    
      <category term="其他" scheme="https://tropical-forest.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="快捷键" scheme="https://tropical-forest.github.io/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    
  </entry>
  
  <entry>
    <title>一次很愉快的跑步</title>
    <link href="https://tropical-forest.github.io/2020/10/10/%E4%B8%80%E6%AC%A1%E5%BE%88%E6%84%89%E5%BF%AB%E7%9A%84%E8%B7%91%E6%AD%A5/"/>
    <id>https://tropical-forest.github.io/2020/10/10/%E4%B8%80%E6%AC%A1%E5%BE%88%E6%84%89%E5%BF%AB%E7%9A%84%E8%B7%91%E6%AD%A5/</id>
    <published>2020-10-10T13:46:59.000Z</published>
    <updated>2021-05-02T13:36:59.361Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;今天晚上跑步很愉快、很顺利、很幸运。今天给自己的目标是15km.原以为会跟这周三一样跑5公里就会放弃。刚跑3公里左右右脚确实有点痛，但坚持跑了几圈后脚就不痛了。这是在北区跑，佩戴新买的肩包，我跑起来感觉不累，感觉很轻松。不知道是为什么今天跑步感觉很轻松。分析一下原因:</p><ul><li><p>1.现在是秋季，温度不热不冷，很适合跑步</p></li><li><p>2.跑步时间是在晚上，晚上跑步较为轻松一些，不想黄昏是那么炎热，黄昏是跑步比晚上跑步容易流汗容易累</p></li><li><p>3.上次跑步只跑5公里，对体力没有大的消耗，体力保存较多，这是跑步可以说是占了上次的便宜</p></li><li><p>4.跑步地点。这次在北区跑，北区跑步的人较多，比南区有较为浓厚的氛围。而且女生多，跑步起来当然要认真跑啊，跑慢对形象多不好啊，认真跑起来万一能脱单呢。</p></li><li><p>5.感觉北区的跑道比南区的跑道弹性更好，当然这是个人感觉啦</p></li></ul><p>以上是跑步轻松的原因。除了轻松以外。这是跑步也遇到几个同班同学，这对我以前跑步从来没遇到而今天突然遇到感到莫名的惊喜。虽然跑步向来是孤独者的运动，但能在跑步路上遇到熟人，当然也是一件很惊喜的事情。最后我跑完后在跑道漫步两圈时，在最后要回去的时候，突然响起李宗盛的沧桑的嗓音，这对于我来说实在是一件很惊喜的事。</p><p>还有这是跑步我突然想到了爱，我想到爱不是自私的爱，而是一种博爱，爱世上的一些，爱并不应该是自私的，爱是博大的，爱是无处不在，我爱花草、我爱聪慧的她、我爱天上的星星、我也爱我的对手、我爱我所看到一些、也爱我未曾看到的一些。</p><p>最后，对于这次跑步我是很满足、很高兴的，希望下次能继续保持愉快的跑步。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;今天晚上跑步很愉快、很顺利、很幸运。今天给自己的目标是15km.原以为会跟这周三一样跑5公里就会放弃。刚跑3公里左右右脚确实有点痛，但坚持跑了几圈后脚就不痛了。这是在北区跑，佩戴新买的肩包，我跑起来感觉不累，感觉很轻松。不知道
      
    
    </summary>
    
    
      <category term="生活日志" scheme="https://tropical-forest.github.io/categories/%E7%94%9F%E6%B4%BB%E6%97%A5%E5%BF%97/"/>
    
    
  </entry>
  
  <entry>
    <title>合并排序</title>
    <link href="https://tropical-forest.github.io/2020/10/04/%E5%90%88%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <id>https://tropical-forest.github.io/2020/10/04/%E5%90%88%E5%B9%B6%E6%8E%92%E5%BA%8F/</id>
    <published>2020-10-04T02:55:11.000Z</published>
    <updated>2020-10-04T03:03:11.201Z</updated>
    
    <content type="html"><![CDATA[<p>合并排序算法是用分治策略实现对n个元素进行排序的算法。其基本思想是:将待排序元素分成大小大致相同的2个字集合，分别对2个子集合进行排序，最终将排好序的子集合合并成为所要求的排好序的集合。<br>算法描述代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] a,<span class="keyword">int</span> low,<span class="keyword">int</span> high) &#123;</span><br><span class="line"><span class="keyword">int</span> mid=(low+high)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(low&lt;high) &#123;</span><br><span class="line">sort(a,low,mid);</span><br><span class="line">sort(a,mid+<span class="number">1</span>,high);</span><br><span class="line">merge(a,low,mid,high);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> low,<span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[high-low+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> i = low;</span><br><span class="line"><span class="keyword">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 把较小的数先移到新数组中</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=high)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&lt;a[j])&#123;</span><br><span class="line">                temp[k++] = a[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                temp[k++] = a[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把左边剩余的数移入数组 </span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid)&#123;</span><br><span class="line">            temp[k++] = a[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把右边边剩余的数移入数组</span></span><br><span class="line">        <span class="keyword">while</span>(j&lt;=high)&#123;</span><br><span class="line">            temp[k++] = a[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把新数组中的数覆盖nums数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;temp.length;x++)&#123;</span><br><span class="line">            a[x+low] = temp[x];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度分析:<br>T(n)={O(1) n&lt;=1 ;2T(n/2)+O(n)  n&gt;1}<br>解此递归方程可以T(n)=O(nlogn).由于排序问题的计算时间下界为Ω(nlogn)，故合并排序算法是渐近最优算法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;合并排序算法是用分治策略实现对n个元素进行排序的算法。其基本思想是:将待排序元素分成大小大致相同的2个字集合，分别对2个子集合进行排序，最终将排好序的子集合合并成为所要求的排好序的集合。&lt;br&gt;算法描述代码如下:&lt;/p&gt;
&lt;figure class=&quot;highlight j
      
    
    </summary>
    
    
      <category term="算法设计与分析" scheme="https://tropical-forest.github.io/categories/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"/>
    
    
  </entry>
  
  <entry>
    <title>棋牌覆盖</title>
    <link href="https://tropical-forest.github.io/2020/10/04/%E6%A3%8B%E7%89%8C%E8%A6%86%E7%9B%96/"/>
    <id>https://tropical-forest.github.io/2020/10/04/%E6%A3%8B%E7%89%8C%E8%A6%86%E7%9B%96/</id>
    <published>2020-10-04T02:04:07.000Z</published>
    <updated>2020-10-04T02:29:57.507Z</updated>
    
    <content type="html"><![CDATA[<p>转载<a href="https://www.xiaowuyike.com/archives/383.html" target="_blank" rel="noopener">棋牌覆盖问题（java实现)</a></p><p>棋牌覆盖问题（java实现）</p><p>一、问题描述与分析</p><p>问题：在一个<br>2<sup>k</sup> * 2<sup>k</sup><br>方格组成的棋盘中，有一个方格与其它的不同，用如下图的4种不同形态的L型骨牌覆盖给定的特殊棋盘上除特殊方格以外的所有方格，且任何2个L型骨牌不得重叠覆盖。<br><img src="/2020/10/04/%E6%A3%8B%E7%89%8C%E8%A6%86%E7%9B%96/gupd.md.png" alt="骨牌"></p><p>分析：用分治法划分棋盘，使划分后的子棋盘的大小相同，并且每个子棋盘均包含一个特殊方格，从而将原问题分解为规模较小的棋盘覆盖问题。k&gt;0时，可将</p><p>2<sup>k</sup> * 2<sup>k</sup><br>的棋盘划分为4个</p><p>2<sup>k</sup>-1 * 2<sup>k</sup>-1<br>的子棋盘。<br><img src="/2020/10/04/%E6%A3%8B%E7%89%8C%E8%A6%86%E7%9B%96/qipj.md.png" alt="骨牌"></p><p>这样划分后，由于原棋盘只有一个特殊方格，所以，这4个子棋盘中只有一个子棋盘包含该特殊方格，其余3个子棋盘中没有特殊方格。为了将这3个没有特殊方格的子棋盘转化为特殊棋盘，以便采用递归方法求解，可以用一个L型骨牌覆盖这3个较小棋盘的会合处（如图2），从而将原问题转化为4个较小规模的棋盘覆盖问题。<br><img src="/2020/10/04/%E6%A3%8B%E7%89%8C%E8%A6%86%E7%9B%96/erqipj.md.png" alt="子骨牌"><br>递归地使用这种划分策略，直至将棋盘分割为1×1的子棋盘。<br>二、程序实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChessBord</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[][] matrix;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">"棋盘大小："</span>);</span><br><span class="line">        <span class="keyword">while</span> (in.hasNextInt()) &#123;</span><br><span class="line">            <span class="keyword">int</span> n = in.nextInt();<span class="comment">//棋盘大小</span></span><br><span class="line">            System.out.println(<span class="string">"特殊方格位置："</span>);</span><br><span class="line">            <span class="keyword">int</span> dr = in.nextInt();<span class="comment">//特殊方格的行号</span></span><br><span class="line">            <span class="keyword">int</span> dc = in.nextInt();<span class="comment">//特殊方格的列号</span></span><br><span class="line">            matrix = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];<span class="comment">//n*n的棋盘大小</span></span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">            chessBoard(<span class="number">0</span>, <span class="number">0</span>, dr, dc, n);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>[] ii : matrix) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> jj : ii) &#123;</span><br><span class="line">                    System.out.printf(<span class="string">"%8d"</span>, jj);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * n：表示输入矩阵是n*n的方阵</span></span><br><span class="line"><span class="comment">     * tr：棋盘左上角方格的行号；tc：棋盘左上角方格的列号</span></span><br><span class="line"><span class="comment">     * dr：特殊方格的行号；dc：特殊方格的列号</span></span><br><span class="line"><span class="comment">     * size：棋盘的大小是size×size</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">chessBoard</span><span class="params">(<span class="keyword">int</span> tr, <span class="keyword">int</span> tc, <span class="keyword">int</span> dr, <span class="keyword">int</span> dc, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果当前棋盘的尺寸是1,也就是说只有一个方格的时候,返回函数</span></span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> curPattern = ++count;</span><br><span class="line">        <span class="comment">//把棋盘从中间平均分为4个部分,</span></span><br><span class="line">        size = size / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//下面方法分别检索分隔出来的4个部分</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//左上部分</span></span><br><span class="line">        <span class="keyword">if</span> (dr &lt; tr + size &amp;&amp; dc &lt; tc + size) &#123;</span><br><span class="line">            <span class="comment">//如果左上部分包含特殊棋盘，那么就直接递归找左上部分,继续把左上部分分隔</span></span><br><span class="line">            chessBoard(tr, tc, dr, dr, size);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果左上部分不包含特殊棋盘，那么先把左上部分的右下角自定义一个特殊棋盘，然后在递归</span></span><br><span class="line">            matrix[tr + size - <span class="number">1</span>][tc + size - <span class="number">1</span>] = curPattern;</span><br><span class="line">            chessBoard(tr, tc, tr + size - <span class="number">1</span>, tc + size - <span class="number">1</span>, size);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//右上部分</span></span><br><span class="line">        <span class="keyword">if</span> (dr &lt; tr + size &amp;&amp; dc &gt;= tc + size) &#123;</span><br><span class="line">            chessBoard(tr, tc + size, dr, dc, size);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            matrix[tr + size - <span class="number">1</span>][tc + size] = curPattern;</span><br><span class="line">            chessBoard(tr, tc + size, tr + size - <span class="number">1</span>, tc + size, size);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//左下部分</span></span><br><span class="line">        <span class="keyword">if</span> (dr &gt;= tr + size &amp;&amp; dc &lt; tc + size) &#123;</span><br><span class="line">            chessBoard(tr + size, tc, dr, dc, size);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            matrix[tr + size][tc + size - <span class="number">1</span>] = curPattern;</span><br><span class="line">            chessBoard(tr + size, tc, tr + size, tc + size - <span class="number">1</span>, size);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//右下部分</span></span><br><span class="line">        <span class="keyword">if</span> (dr &gt;= tr + size &amp;&amp; dc &gt;= tc + size) &#123;</span><br><span class="line">            chessBoard(tr + size, tc + size, dr, dc, size);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            matrix[tr + size][tc + size] = curPattern;</span><br><span class="line">            chessBoard(tr + size, tc + size, tr + size, tc + size, size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>三、实验结果与分析</p><p>实验结果：<br><img src="/2020/10/04/%E6%A3%8B%E7%89%8C%E8%A6%86%E7%9B%96/jpgo.md.png" alt="实验结果"></p><p>实验分析：</p><p>用递归与分治的思想来解决，也就是把一个大的棋盘分成4个小棋盘，检索填充，然后在把小棋盘继续细分，直到棋盘中只包含一个格子为止。</p><p>主干是四个if else循环，也就是说只会执行一个if中的语句，但是会执行3个else中的语句，这3个else中的语句就是构造不可覆盖格子，然后对含有新构造的不可覆盖点的子棋盘来重写进行棋盘覆盖，也就是递归调用棋盘覆盖函数，递归的结束条件就是子棋盘只有一个格子，也就是size = 1，每次调用棋盘覆盖函数，都要进行size = size/2，目的就是把一个大棋盘划分为四个相同大小的子棋盘。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转载&lt;a href=&quot;https://www.xiaowuyike.com/archives/383.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;棋牌覆盖问题（java实现)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;棋牌覆盖问题（java实现）&lt;/p&gt;
&lt;p&gt;一
      
    
    </summary>
    
    
      <category term="算法设计与分析" scheme="https://tropical-forest.github.io/categories/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"/>
    
    
  </entry>
  
  <entry>
    <title>排列问题</title>
    <link href="https://tropical-forest.github.io/2020/10/03/%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98/"/>
    <id>https://tropical-forest.github.io/2020/10/03/%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98/</id>
    <published>2020-10-03T06:31:31.000Z</published>
    <updated>2020-10-03T06:49:25.745Z</updated>
    
    <content type="html"><![CDATA[<p>问题描述</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">问题描述：对n个元素进行全排列，列出所有情况，例如1，2，3三个数字会得到1 2 3，1 3 2，2 1 3，2 3 1，3 1 2，3 2 1这6中情况</span><br><span class="line"></span><br><span class="line">思路：设n为元素个数，元素集合为R(r1,r2,r3....rn)，计算方法为Perm(n)</span><br><span class="line"></span><br><span class="line">当n &#x3D; 1时，则只有一种情况  r；</span><br><span class="line"></span><br><span class="line">当n &gt; 1时，则有(r1)Perm(R1),(r2)Perm(R2),(r3)Perm(R3) ... ... (rn)Perm(Rn)</span><br><span class="line"></span><br><span class="line">                  以1，2，3为例全排列，共有以下排列：</span><br><span class="line"></span><br><span class="line">                 1 Perm(2,3)  即：以1为前缀的所有组合</span><br><span class="line"></span><br><span class="line">                 2 Perm(1,3)  即：以2为前缀的所有组合</span><br><span class="line"></span><br><span class="line">                 3 Perm(2,3)  即：以3为前缀的所有组合</span><br><span class="line"></span><br><span class="line">注：Perm(k,m)利用递归的思想即可不断划分前缀，直到只剩下1个元素，则只有一种情况，即为找到了一种排列。</span><br></pre></td></tr></table></figure><p>代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ch3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Perm</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Object []list,<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">Object temp;</span><br><span class="line">temp = list[a];</span><br><span class="line">list[a] = list[b];</span><br><span class="line">list[b] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">perm</span><span class="params">(Object []list, <span class="keyword">int</span> k, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(k==m) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m;i++) &#123;</span><br><span class="line">System.out.print(list[i]);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=k;i&lt;=m;i++) &#123;</span><br><span class="line">swap(list,k,i);</span><br><span class="line">perm(list,k+<span class="number">1</span>,m);</span><br><span class="line">swap(list,k,i);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Object[] list = <span class="keyword">new</span> Object[<span class="number">6</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++) &#123;</span><br><span class="line">list[i] = i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">perm(list,<span class="number">0</span>,list.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>算法解析</strong><br>算法perm(list,k,m)递归地产生所以前缀list[0:k-1],且后缀时list[k:m]的全排列的所有排列。swap算法用于交换两个表元素的值。因为每次递归都会使用一个辅助空间，所以空间复杂性为O(n)。因为递归了n次，所以时间复杂性为O(n)。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;问题描述&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br
      
    
    </summary>
    
    
      <category term="算法设计与分析" scheme="https://tropical-forest.github.io/categories/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"/>
    
    
  </entry>
  
  <entry>
    <title>算法复杂性分析</title>
    <link href="https://tropical-forest.github.io/2020/10/03/%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E6%80%A7%E5%88%86%E6%9E%90/"/>
    <id>https://tropical-forest.github.io/2020/10/03/%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E6%80%A7%E5%88%86%E6%9E%90/</id>
    <published>2020-10-03T01:28:25.000Z</published>
    <updated>2020-10-03T01:58:34.503Z</updated>
    
    <content type="html"><![CDATA[<p>算法复杂性的高低体现在运行该算法所需要的计算机资源的多少上，所需要的资源多，算法复杂性就越高；反之越少，算法复杂性就越低。算法复杂性主要分为时间复杂性和空间复杂性，顾名思义就是运行该算法所花费的时间和空间资源。算法复杂性分析对指导算法设计与分析具有重要意义。</p><h2 id="时间复杂性"><a href="#时间复杂性" class="headerlink" title="时间复杂性"></a>时间复杂性</h2><p>时间复杂性分析主要通过渐近上界、渐近下界、同阶方法进行分析</p><h3 id="渐近上界"><a href="#渐近上界" class="headerlink" title="渐近上界"></a>渐近上界</h3><p><strong>记号:</strong> O<br><strong>定义</strong><br>对所有 n，f(n)&gt;=0，g(n)&gt;=0,O(g(n))= { f(n) | 存在正常数 存在正常数 c和n0使得对所有 n&gt;=n0有： 0&lt;=f(n)&lt;=cg(n)}</p><h3 id="渐近下界"><a href="#渐近下界" class="headerlink" title="渐近下界"></a>渐近下界</h3><p><strong>记号:</strong> Ω<br><strong>定义</strong><br>对所有 n，f(n)&gt;=0，g(n)&gt;=0,Ω(g(n))= { f(n) | 存在正常数 存在正常数 c和n0使得对所有 n&gt;=n0有： 0&lt;=cg(n)&lt;=f(n)}</p><h3 id="同阶"><a href="#同阶" class="headerlink" title="同阶"></a>同阶</h3><p><strong>记号:</strong> Θ<br>O(f(n)) = Ω(f(n))</p><h2 id="空间复杂性"><a href="#空间复杂性" class="headerlink" title="空间复杂性"></a>空间复杂性</h2><p>空间复杂性分析较为简单，方法与时间复杂性分析相似</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;算法复杂性的高低体现在运行该算法所需要的计算机资源的多少上，所需要的资源多，算法复杂性就越高；反之越少，算法复杂性就越低。算法复杂性主要分为时间复杂性和空间复杂性，顾名思义就是运行该算法所花费的时间和空间资源。算法复杂性分析对指导算法设计与分析具有重要意义。&lt;/p&gt;
&lt;h2
      
    
    </summary>
    
    
      <category term="算法设计与分析" scheme="https://tropical-forest.github.io/categories/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"/>
    
    
  </entry>
  
  <entry>
    <title>二叉树的中序遍历</title>
    <link href="https://tropical-forest.github.io/2020/09/14/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>https://tropical-forest.github.io/2020/09/14/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</id>
    <published>2020-09-14T13:03:24.000Z</published>
    <updated>2021-05-02T13:37:25.353Z</updated>
    
    <content type="html"><![CDATA[<p>题目描述:<br><img src="/2020/09/14/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/二叉树的中序遍历.JPG" alt="题目描述"></p><h3 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h3><p> 常见的二叉树的遍历方法是先序遍历、中序遍历和后序遍历。</p><p> 先序：考察到一个节点后，即刻输出该节点的值，并继续遍历其左右子树。(根左右)</p><p>中序：考察到一个节点后，将其暂存，遍历完左子树后，再输出该节点的值，然后遍历右子树。(左根右)</p><p>后序：考察到一个节点后，将其暂存，遍历完左右子树后，再输出该节点的值。(左右根)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        inorder(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        inorder(root.left, res);</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        inorder(root.right, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度:O(n),因为二叉树的结点时n个，且每一个结点会被访问一次仅只有一次。<br>空间复杂度:O(n),空间复杂度取决于递归的栈深度，而栈深度在二叉树为一条链的情况下会达到 O(n)O(n) 的级别。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目描述:&lt;br&gt;&lt;img src=&quot;/2020/09/14/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/二叉树的中序遍历.JPG&quot; alt=&quot;题目描述&quot;&gt;&lt;/p&gt;
&lt;h3
      
    
    </summary>
    
    
      <category term="其他" scheme="https://tropical-forest.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="中序遍历" scheme="https://tropical-forest.github.io/tags/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>Webpack的安装</title>
    <link href="https://tropical-forest.github.io/2020/09/05/Webpack%E7%9A%84%E5%AE%89%E8%A3%85/"/>
    <id>https://tropical-forest.github.io/2020/09/05/Webpack%E7%9A%84%E5%AE%89%E8%A3%85/</id>
    <published>2020-09-05T03:12:18.000Z</published>
    <updated>2021-05-02T13:34:17.228Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Webpack介绍"><a href="#Webpack介绍" class="headerlink" title="Webpack介绍"></a>Webpack介绍</h2><p>Webpack是一个开源的前端开发工具。当Webpack处理应用程序时，它会构建一个依赖关系图，其中包含应用程序所需要的各个模块，然后将所有这些模块打包成一个或多个模组。Webpack可以通过终端或更改Webpack.config.js文件来设定各项功能</p><h2 id="Webpack安装"><a href="#Webpack安装" class="headerlink" title="Webpack安装"></a>Webpack安装</h2><p>前提： 已经装好了node.js、npm可以使用<br>在本地安装:<br><code>npm install --save-dev webpack</code> 安装最新版本Webpack<br><code>npm install --save-dev webpack@&lt;version&gt;</code> 安装指定版本Webpack<br>最后把<code>node_modules\.bin</code>路径加到path路径下<br>在cmd上输入<code>webpack -v</code>若有显示版本号则安装成功</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Webpack介绍&quot;&gt;&lt;a href=&quot;#Webpack介绍&quot; class=&quot;headerlink&quot; title=&quot;Webpack介绍&quot;&gt;&lt;/a&gt;Webpack介绍&lt;/h2&gt;&lt;p&gt;Webpack是一个开源的前端开发工具。当Webpack处理应用程序时，它会构建一个
      
    
    </summary>
    
    
      <category term="其他" scheme="https://tropical-forest.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="Webpack" scheme="https://tropical-forest.github.io/tags/Webpack/"/>
    
  </entry>
  
</feed>
